module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/Users/slvn/Desktop/botpress";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	if (!global._babelPolyfill) {
	  __webpack_require__(2);
	}
	
	var path = __webpack_require__(3);
	
	var DatabaseHelpers = __webpack_require__(4);
	
	var CLI = function CLI() {
	  return __webpack_require__(6);
	};
	var Botpress = function Botpress() {
	  return __webpack_require__(36);
	};
	
	module.exports = { Botpress: Botpress, DatabaseHelpers: DatabaseHelpers, CLI: CLI };

/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = require("babel-polyfill");

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = require("path");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _moment = __webpack_require__(5);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _isLite = function _isLite(knex) {
	  return knex.client.config.client === 'sqlite3';
	}; /*
	     The goal of these helpers is to generate SQL queries
	     that are valid for both SQLite and Postgres
	   */
	
	module.exports = function (knex) {
	
	  var dateParse = function dateParse(exp) {
	    return _isLite(knex) ? knex.raw('strftime(\'%Y-%m-%dT%H:%M:%fZ\', ' + exp + ')') : knex.raw(exp);
	  };
	
	  var dateFormat = function dateFormat(date) {
	    var iso = (0, _moment2.default)(date).toDate().toISOString();
	    return dateParse('\'' + iso + '\'');
	  };
	
	  var columnOrDateFormat = function columnOrDateFormat(colOrDate) {
	    var lite = _isLite(knex);
	
	    if (colOrDate.sql) {
	      return colOrDate.sql;
	    }
	
	    if (typeof colOrDate === 'string') {
	      return lite ? dateParse(colOrDate) : '"' + colOrDate + '"';
	    }
	
	    return dateFormat(colOrDate);
	  };
	
	  return {
	    isLite: function isLite() {
	      return _isLite(knex);
	    },
	
	    // knex's createTableIfNotExists doesn't work with postgres
	    // https://github.com/tgriesser/knex/issues/1303
	    createTableIfNotExists: function createTableIfNotExists(tableName, cb) {
	      return knex.schema.hasTable(tableName).then(function (exists) {
	        if (exists) {
	          return;
	        }
	        return knex.schema.createTableIfNotExists(tableName, cb);
	      });
	    },
	
	    date: {
	      format: dateFormat,
	
	      now: function now() {
	        return _isLite(knex) ? knex.raw("strftime('%Y-%m-%dT%H:%M:%fZ', 'now')") : knex.raw('now()');
	      },
	
	      isBefore: function isBefore(d1, d2) {
	        d1 = columnOrDateFormat(d1);
	        d2 = columnOrDateFormat(d2);
	
	        return knex.raw(d1 + ' < ' + d2);
	      },
	
	      isAfter: function isAfter(d1, d2) {
	        d1 = columnOrDateFormat(d1);
	        d2 = columnOrDateFormat(d2);
	
	        return knex.raw(d1 + ' > ' + d2);
	      },
	
	      isBetween: function isBetween(d1, d2, d3) {
	        d1 = columnOrDateFormat(d1);
	        d2 = columnOrDateFormat(d2);
	        d3 = columnOrDateFormat(d3);
	
	        return knex.raw(d1 + ' BETWEEN ' + d2 + ' AND ' + d3);
	      },
	
	      isSameDay: function isSameDay(d1, d2) {
	        d1 = columnOrDateFormat(d1);
	        d2 = columnOrDateFormat(d2);
	
	        return knex.raw('date(' + d1 + ') = date(' + d2 + ')');
	      },
	
	      hourOfDay: function hourOfDay(date) {
	        date = columnOrDateFormat(date);
	        return _isLite(knex) ? knex.raw('strftime(\'%H\', ' + date + ')') : knex.raw('to_char(' + date + ', \'HH24\')');
	      }
	    },
	
	    bool: {
	
	      true: function _true() {
	        return _isLite(knex) ? 1 : true;
	      },
	      false: function _false() {
	        return _isLite(knex) ? 0 : false;
	      },
	      parse: function parse(value) {
	        return _isLite(knex) ? !!value : value;
	      }
	
	    },
	
	    json: {
	      set: function set(obj) {
	        return _isLite(knex) ? obj && JSON.stringify(obj) : obj;
	      },
	      get: function get(obj) {
	        return _isLite(knex) ? obj && JSON.parse(obj) : obj;
	      }
	    }
	
	  };
	};

/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = require("moment");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _commander = __webpack_require__(7);
	
	var _commander2 = _interopRequireDefault(_commander);
	
	var _init = __webpack_require__(8);
	
	var _init2 = _interopRequireDefault(_init);
	
	var _start = __webpack_require__(21);
	
	var _start2 = _interopRequireDefault(_start);
	
	var _create = __webpack_require__(22);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _install = __webpack_require__(23);
	
	var _install2 = _interopRequireDefault(_install);
	
	var _uninstall = __webpack_require__(29);
	
	var _uninstall2 = _interopRequireDefault(_uninstall);
	
	var _migrate = __webpack_require__(30);
	
	var _migrate2 = _interopRequireDefault(_migrate);
	
	var _list = __webpack_require__(35);
	
	var _list2 = _interopRequireDefault(_list);
	
	var _util = __webpack_require__(14);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_commander2.default.command('init').description('Create a new bot in current directory').option('-y, --yes', 'Say yes to every prompt and use default values').action(_init2.default);
	
	_commander2.default.command('start [path]').alias('s').description('Starts running a bot').action(_start2.default);
	
	_commander2.default.command('install <module> [modules...]').alias('i').description('Add modules to the current bot').action(_install2.default);
	
	_commander2.default.command('uninstall <module> [modules...]').alias('u').description('Remove modules from the current bot').action(_uninstall2.default);
	
	_commander2.default.command('list').alias('ls').description('List installed modules').action(_list2.default);
	
	_commander2.default.command('create').alias('c').description('Create a new module for development or distribution').action(_create2.default);
	
	_commander2.default.command('migrate <fromVersion>').description('Migrates the current bot from version X').action(_migrate2.default);
	
	_commander2.default.version((0, _util.getBotpressVersion)()).description('Easily create, manage and extend chatbots.').parse(process.argv);
	
	if (!_commander2.default.args.length) {
	  _commander2.default.help();
	}

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = require("commander");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _child_process = __webpack_require__(9);
	
	var _prompt = __webpack_require__(10);
	
	var _prompt2 = _interopRequireDefault(_prompt);
	
	var _chalk = __webpack_require__(11);
	
	var _chalk2 = _interopRequireDefault(_chalk);
	
	var _path = __webpack_require__(3);
	
	var _path2 = _interopRequireDefault(_path);
	
	var _lodash = __webpack_require__(12);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _fs = __webpack_require__(13);
	
	var _fs2 = _interopRequireDefault(_fs);
	
	var _util = __webpack_require__(14);
	
	var _util2 = _interopRequireDefault(_util);
	
	var _stats = __webpack_require__(16);
	
	var _stats2 = _interopRequireDefault(_stats);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var introductionText = "\nHey there, thanks for using botpress!" + "\nWe'll walk you through the creation of your new bot." + "\nFor more information or help, please visit http://github.com/botpress/botpress" + "\n---------------";
	
	var waitingText = 'please wait, we are installing everything for you...';
	var nextStepText = 'now run ' + _chalk2.default.bold('`bp start`') + ' in your terminal';
	
	var assertDoesntExist = function assertDoesntExist(file) {
	  if (_fs2.default.existsSync(file)) {
	    _util2.default.print('error', 'package.json or botfile.js are already in repository, ' + 'remove them before running this command again.');
	    process.exit(1);
	  }
	};
	
	var getTemplate = function getTemplate(template) {
	  var templatePath = _path2.default.join(__dirname, 'cli/templates/init', template);
	  var templateContent = _fs2.default.readFileSync(templatePath);
	  return _lodash2.default.template(templateContent);
	};
	
	var generateTemplate = function generateTemplate(filename) {
	  var variables = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	  var template = getTemplate(filename);
	  var compiled = template(variables);
	  var destination = _path2.default.join(filename.replace(/_\._/, '.'));
	  _fs2.default.writeFileSync(destination, compiled);
	};
	
	var generate = function generate(result) {
	  generateTemplate('package.json', result);
	  generateTemplate('LICENSE');
	  generateTemplate('botfile.js');
	  generateTemplate('index.js');
	  generateTemplate('content.yml');
	  generateTemplate('_._gitignore');
	  generateTemplate('_._welcome');
	  generateTemplate('theme.scss');
	
	  _fs2.default.mkdirSync('data');
	  _fs2.default.writeFileSync('data/bot.log', '');
	  _fs2.default.writeFileSync('data/notification.json', '[]');
	
	  _fs2.default.mkdirSync('modules_config');
	
	  _util2.default.print(waitingText);
	  var install = (0, _child_process.spawn)(_util2.default.npmCmd, ['install']);
	
	  install.stdout.on('data', function (data) {
	    process.stdout.write(data.toString());
	  });
	
	  install.stderr.on('data', function (data) {
	    process.stdout.write(data.toString());
	  });
	
	  install.on('close', function (code) {
	    if (code > 0) {
	      _util2.default.print('error', 'an error occured during installation');
	    } else {
	      _util2.default.print('success', 'installation has completed successfully');
	      _util2.default.print(nextStepText);
	    }
	  });
	};
	
	module.exports = function (program) {
	  var dirName = process.argv[3];
	  if (dirName != undefined) {
	    if (!_fs2.default.existsSync(dirName)) {
	      _fs2.default.mkdirSync(dirName);
	      process.chdir(dirName);
	    } else {
	      _util2.default.print('error', dirName + " directory already exists");
	      return;
	    }
	  }
	  (0, _stats2.default)({}).track('cli', 'bot', 'init');
	
	  _util2.default.print(introductionText);
	
	  _lodash2.default.each(['package.json', 'botfile.js', 'index.js'], assertDoesntExist);
	
	  var currentDirectoryName = _path2.default.basename(_path2.default.resolve('./'));
	
	  var schema = {
	    properties: {
	      name: {
	        description: _chalk2.default.white('name:'),
	        pattern: /^[a-z0-9][a-z0-9-_\.]+$/,
	        message: 'name must be only lowercase letters, ' + 'digits, dashes, underscores and dots.',
	        required: true,
	        default: currentDirectoryName
	      },
	      description: {
	        required: false,
	        description: _chalk2.default.white('description:')
	      },
	      author: {
	        required: false,
	        description: _chalk2.default.white('author:')
	      },
	      version: {
	        required: false,
	        description: _chalk2.default.white('version:'),
	        default: '0.0.1'
	      }
	    }
	  };
	
	  if (program.yes) {
	    generate({
	      name: currentDirectoryName,
	      description: '',
	      author: '',
	      version: '0.0.1'
	    });
	  } else {
	    _prompt2.default.message = '';
	    _prompt2.default.delimiter = '';
	    _prompt2.default.start();
	    _prompt2.default.get(schema, function (err, result) {
	      generate(result);
	    });
	  }
	};

/***/ },
/* 9 */
/***/ function(module, exports) {

	module.exports = require("child_process");

/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = require("prompt");

/***/ },
/* 11 */
/***/ function(module, exports) {

	module.exports = require("chalk");

/***/ },
/* 12 */
/***/ function(module, exports) {

	module.exports = require("lodash");

/***/ },
/* 13 */
/***/ function(module, exports) {

	module.exports = require("fs");

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _chalk = __webpack_require__(11);
	
	var _chalk2 = _interopRequireDefault(_chalk);
	
	var _path = __webpack_require__(3);
	
	var _path2 = _interopRequireDefault(_path);
	
	var _module = __webpack_require__(15);
	
	var _module2 = _interopRequireDefault(_module);
	
	var _fs = __webpack_require__(13);
	
	var _fs2 = _interopRequireDefault(_fs);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var IS_DEV = process.env.NODE_ENV !== 'production';
	
	var NPM_CMD = /^win/.test(process.platform) ? 'npm.cmd' : 'npm';
	
	var print = function print() {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }
	
	  var mapping = {
	    info: _chalk2.default.white,
	    warn: function warn() {
	      return _chalk2.default.yellow.apply(_chalk2.default, ['WARN'].concat(Array.prototype.slice.call(arguments)));
	    },
	    error: function error() {
	      return _chalk2.default.red.apply(_chalk2.default, ['ERR'].concat(Array.prototype.slice.call(arguments)));
	    },
	    success: function success() {
	      return _chalk2.default.green.apply(_chalk2.default, ['OK'].concat(Array.prototype.slice.call(arguments)));
	    }
	  };
	
	  var level = mapping[args[0]];
	  var matched = !!level;
	
	  if (!matched) {
	    level = mapping.info;
	  } else {
	    args.splice(0, 1);
	  }
	
	  console.log(_chalk2.default.black.bgWhite('[botpress]'), '\t', level.apply(undefined, args));
	};
	
	var resolveFromDir = function resolveFromDir(fromDir, moduleId) {
	  fromDir = _path2.default.resolve(fromDir);
	  var fromFile = _path2.default.join(fromDir, 'noop.js');
	  try {
	    return _module2.default._resolveFilename(moduleId, {
	      id: fromFile,
	      filename: fromFile,
	      paths: _module2.default._nodeModulePaths(fromDir)
	    });
	  } catch (err) {
	    return null;
	  }
	};
	
	var resolveModuleRootPath = function resolveModuleRootPath(entryPath) {
	  var current = _path2.default.dirname(entryPath);
	  while (current !== '/') {
	    var lookup = _path2.default.join(current, 'package.json');
	    if (_fs2.default.existsSync(lookup)) {
	      return current;
	    }
	    current = _path2.default.resolve(_path2.default.join(current, '..'));
	  }
	  return null;
	};
	
	var resolveProjectFile = function resolveProjectFile(file, projectLocation, throwIfNotExist) {
	  var packagePath = _path2.default.resolve(projectLocation || './', file);
	
	  if (!_fs2.default.existsSync(packagePath)) {
	    if (throwIfNotExist) {
	      throw new Error('Could not find bot\'s package.json file');
	    }
	    return null;
	  }
	
	  return packagePath;
	};
	
	var getBotpressVersion = function getBotpressVersion() {
	  var botpressPackagePath = _path2.default.join(__dirname, '../package.json');
	  var botpressJson = JSON.parse(_fs2.default.readFileSync(botpressPackagePath));
	  return botpressJson.version;
	};
	
	module.exports = {
	  print: print,
	  resolveFromDir: resolveFromDir,
	  isDeveloping: IS_DEV,
	  resolveModuleRootPath: resolveModuleRootPath,
	  resolveProjectFile: resolveProjectFile,
	  npmCmd: NPM_CMD,
	  getBotpressVersion: getBotpressVersion
	};

/***/ },
/* 15 */
/***/ function(module, exports) {

	module.exports = require("module");

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _os = __webpack_require__(17);
	
	var _os2 = _interopRequireDefault(_os);
	
	var _crypto = __webpack_require__(18);
	
	var _crypto2 = _interopRequireDefault(_crypto);
	
	var _universalAnalytics = __webpack_require__(19);
	
	var _universalAnalytics2 = _interopRequireDefault(_universalAnalytics);
	
	var _nodeMachineId = __webpack_require__(20);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = function (botfile) {
	
	  var visitor = null;
	  var queued = [];
	
	  (0, _nodeMachineId.machineId)().catch(function () {
	    var hash = _crypto2.default.createHash('sha256');
	    hash.update(_os2.default.arch() + _os2.default.hostname() + _os2.default.platform() + _os2.default.type());
	    return hash.digest('hex');
	  }).then(function (mid) {
	    visitor = (0, _universalAnalytics2.default)('UA-90044826-1', mid, { strictCidFormat: false });
	    queued.forEach(function (a) {
	      return a();
	    });
	    queued = [];
	  });
	
	  var track = function track(category, action) {
	    var label = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	    var value = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	
	    if (!!botfile.optOutStats) {
	      return; // Don't track if bot explicitly opted out from stats collection
	    }
	
	    if (!visitor) {
	      queued.push(function () {
	        return track(category, action, label, value);
	      });
	      return;
	    }
	
	    visitor.event(category, action, label, value, function () {/* ignore errors */});
	  };
	
	  var trackException = function trackException(message) {
	    if (!!botfile.optOutStats) {
	      return; // Don't track if bot explicitly opted out from stats collection
	    }
	
	    if (!visitor) {
	      queued.push(function () {
	        return trackException(message);
	      });
	      return;
	    }
	
	    visitor.event(message, function () {/* ignore errors */});
	  };
	
	  return { track: track, trackException: trackException };
	};

/***/ },
/* 17 */
/***/ function(module, exports) {

	module.exports = require("os");

/***/ },
/* 18 */
/***/ function(module, exports) {

	module.exports = require("crypto");

/***/ },
/* 19 */
/***/ function(module, exports) {

	module.exports = require("universal-analytics");

/***/ },
/* 20 */
/***/ function(module, exports) {

	module.exports = require("node-machine-id");

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _path = __webpack_require__(3);
	
	var _path2 = _interopRequireDefault(_path);
	
	var _fs = __webpack_require__(13);
	
	var _fs2 = _interopRequireDefault(_fs);
	
	var _util = __webpack_require__(14);
	
	var _util2 = _interopRequireDefault(_util);
	
	var _chalk = __webpack_require__(11);
	
	var _chalk2 = _interopRequireDefault(_chalk);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Entry point of botpress
	 *
	 * It will do the following things:
	 *
	 * 1. Find botpress instance creator in `node_modules` folder in current project.
	 * 2. Find the `botfile.js` which will be injected into the creator to create the instance.
	 * 3. Start the botpress instance.
	 */
	module.exports = function (projectPath, options) {
	  var Botpress = null;
	
	  if (!projectPath || typeof projectPath !== 'string') {
	    projectPath = '.';
	  }
	
	  projectPath = _path2.default.resolve(projectPath);
	
	  try {
	    Botpress = eval('require')(_path2.default.join(projectPath, 'node_modules', 'botpress')).Botpress();
	  } catch (err) {
	    _util2.default.print('error', err.message);
	    _util2.default.print('error', err.stack);
	    _util2.default.print('error', '(fatal) Could not load the local version of botpress');
	    _util2.default.print('Hint: 1) have you used `botpress init` to create a new bot the proper way?');
	    _util2.default.print('Hint: 2) Do you have read and write permissions on the current directory?');
	    _util2.default.print('-------------');
	    _util2.default.print('If none of the above works, this might be a bug in botpress. ' + 'Please contact the Botpress Team on gitter and provide the printed error above.');
	    process.exit(1);
	  }
	
	  var botfile = _path2.default.join(projectPath, 'botfile.js');
	  if (!_fs2.default.existsSync(botfile)) {
	    _util2.default.print('error', '(fatal) No ' + _chalk2.default.bold('botfile.js') + ' file found at: ' + botfile);
	    process.exit(1);
	  }
	
	  var bot = new Botpress({ botfile: botfile });
	  bot.start();
	};

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _child_process = __webpack_require__(9);
	
	var _prompt = __webpack_require__(10);
	
	var _prompt2 = _interopRequireDefault(_prompt);
	
	var _chalk = __webpack_require__(11);
	
	var _chalk2 = _interopRequireDefault(_chalk);
	
	var _path = __webpack_require__(3);
	
	var _path2 = _interopRequireDefault(_path);
	
	var _fs = __webpack_require__(13);
	
	var _fs2 = _interopRequireDefault(_fs);
	
	var _lodash = __webpack_require__(12);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _util = __webpack_require__(14);
	
	var _util2 = _interopRequireDefault(_util);
	
	var _stats = __webpack_require__(16);
	
	var _stats2 = _interopRequireDefault(_stats);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var MODULE_NAME_CONVENTION_BEGINS = 'botpress-';
	var MODULE_NAME_REGEX = new RegExp(/^botpress-.*/g);
	
	var introductionText = "This program will bootstrap a new Botpress module";
	var doneText = "You're all set! The module is boostrapped and ready to be developed.";
	var documentation = "Tip: when coding your bot, use the command `npm run watch` to recompile" + " your module automatically. Also, we strongly recommend that you install your module using " + "`npm link ../path/to/botpress-module` so that your bot always points to the most recent version.";
	
	var getTemplate = function getTemplate(template) {
	  var templatePath = _path2.default.join(__dirname, 'cli/templates/create', template);
	  var templateContent = _fs2.default.readFileSync(templatePath);
	  return _lodash2.default.template(templateContent);
	};
	
	var generateTemplate = function generateTemplate(directory, filename) {
	  var variables = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	
	  var template = getTemplate(filename);
	  var compiled = template(variables);
	  var destination = _path2.default.join(directory, filename.replace(/_\._/, '.'));
	  _fs2.default.writeFileSync(destination, compiled);
	};
	
	var prefixModuleNameWithBotpress = function prefixModuleNameWithBotpress(name) {
	
	  if (!MODULE_NAME_REGEX.test(name)) {
	    _util2.default.print('warn', 'the name of your module needs to begin by "botpress-"');
	    _util2.default.print('warn', 'we renamed your module to ' + _chalk2.default.bold(MODULE_NAME_CONVENTION_BEGINS + name));
	    name = MODULE_NAME_CONVENTION_BEGINS + name;
	  }
	
	  return name;
	};
	
	module.exports = function () {
	  var moduleDirectory = _path2.default.resolve('.');
	  var dirname = _path2.default.basename(moduleDirectory);
	
	  (0, _stats2.default)({}).track('cli', 'modules', 'create');
	
	  _util2.default.print(introductionText);
	
	  var schema = {
	    properties: {
	      name: {
	        description: _chalk2.default.white('module name:'),
	        pattern: /^[a-z0-9][a-z0-9-_\.]+$/,
	        message: 'name must be only lowercase letters, ' + 'digits, dashes, underscores and dots.',
	        required: true,
	        default: dirname
	      },
	      description: {
	        required: false,
	        description: _chalk2.default.white('description:')
	      },
	      author: {
	        required: false,
	        description: _chalk2.default.white('author:')
	      },
	      version: {
	        required: false,
	        description: _chalk2.default.white('version:'),
	        default: '1.0.0'
	      }
	    }
	  };
	
	  _prompt2.default.message = '';
	  _prompt2.default.delimiter = '';
	
	  _prompt2.default.start();
	
	  _prompt2.default.get(schema, function (err, result) {
	    result.name = prefixModuleNameWithBotpress(result.name);
	
	    if (dirname !== result.name) {
	      _util2.default.print('warn', 'We usually recommend that the name of the module directory' + (' (' + dirname + ') be the same as the module name (' + result.name + ')'));
	    }
	
	    if (_fs2.default.existsSync(_path2.default.join(moduleDirectory, 'package.json'))) {
	      _util2.default.print('error', "Expected module directory to be empty / uninitialized");
	      process.exit(1);
	    } else {
	      generateTemplate(moduleDirectory, 'package.json', result);
	      generateTemplate(moduleDirectory, 'LICENSE');
	      generateTemplate(moduleDirectory, 'webpack.js');
	      generateTemplate(moduleDirectory, '_._gitignore');
	      generateTemplate(moduleDirectory, '_._npmignore');
	
	      _fs2.default.mkdirSync(moduleDirectory + '/src');
	      generateTemplate(moduleDirectory, 'src/index.js');
	
	      _fs2.default.mkdirSync(moduleDirectory + '/src/views');
	      generateTemplate(moduleDirectory, 'src/views/index.jsx');
	      generateTemplate(moduleDirectory, 'src/views/style.scss');
	
	      _util2.default.print('Installing dependencies, please wait...');
	
	      var install = (0, _child_process.spawn)(_util2.default.npmCmd, ['install']);
	
	      install.stdout.on('data', function (data) {
	        process.stdout.write(data.toString());
	      });
	
	      install.stderr.on('data', function (data) {
	        process.stdout.write(data.toString());
	      });
	
	      install.on('close', function (code) {
	        if (code > 0) {
	          _util2.default.print('error', 'An error occured during the dependencies installation of your module');
	        } else {
	          _util2.default.print('success', 'Module dependencies installed');
	          _util2.default.print(doneText);
	          _util2.default.print(documentation);
	        }
	      });
	    }
	  });
	};

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _util = __webpack_require__(14);
	
	var _util2 = _interopRequireDefault(_util);
	
	var _modules = __webpack_require__(24);
	
	var _modules2 = _interopRequireDefault(_modules);
	
	var _stats = __webpack_require__(16);
	
	var _stats2 = _interopRequireDefault(_stats);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	var waitingText = 'please wait, we are trying to install your new modules...';
	
	module.exports = function (module, modules) {
	  (0, _stats2.default)({}).track('cli', 'modules', 'install');
	  _util2.default.print('info', waitingText);
	  var modulesManager = (0, _modules2.default)(null, './', null);
	  modulesManager.install.apply(modulesManager, [module].concat(_toConsumableArray(modules)));
	};

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _child_process = __webpack_require__(9);
	
	var _path = __webpack_require__(3);
	
	var _path2 = _interopRequireDefault(_path);
	
	var _fs = __webpack_require__(13);
	
	var _fs2 = _interopRequireDefault(_fs);
	
	var _bluebird = __webpack_require__(25);
	
	var _bluebird2 = _interopRequireDefault(_bluebird);
	
	var _lodash = __webpack_require__(12);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _moment = __webpack_require__(5);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _axios = __webpack_require__(26);
	
	var _axios2 = _interopRequireDefault(_axios);
	
	var _configurator = __webpack_require__(27);
	
	var _util = __webpack_require__(14);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	var MODULES_URL = 'https://s3.amazonaws.com/botpress-io/all-modules.json';
	var FETCH_TIMEOUT = 5000;
	
	module.exports = function (logger, projectLocation, dataLocation, kvs) {
	
	  var log = function log(level) {
	    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }
	
	    if (logger && logger[level]) {
	      logger[level].apply(undefined, args);
	    } else {
	      _util.print.apply(undefined, [level].concat(args));
	    }
	  };
	
	  var fetchAllModules = function fetchAllModules() {
	    return _axios2.default.get(MODULES_URL, { timeout: FETCH_TIMEOUT }).then(function (_ref) {
	      var data = _ref.data;
	      return data;
	    }).catch(function () {
	      return logger.error('Could not fetch modules');
	    });
	  };
	
	  var loadModules = function loadModules(moduleDefinitions, botpress) {
	    var loadedCount = 0;
	    var loadedModules = {};
	
	    moduleDefinitions.forEach(function (mod) {
	      var loader = eval('require')(mod.entry);
	
	      if ((typeof loader === 'undefined' ? 'undefined' : _typeof(loader)) !== 'object') {
	        return logger.warn('Ignoring module ' + mod.name + '. Invalid entry point signature.');
	      }
	
	      mod.handlers = loader;
	
	      try {
	        mod.configuration = (0, _configurator.createConfig)({
	          kvs: kvs,
	          name: mod.name,
	          botfile: botpress.botfile,
	          projectLocation: projectLocation,
	          options: loader.config || {}
	        });
	      } catch (err) {
	        logger.error('Invalid module configuration in module ' + mod.name + ':', err);
	      }
	
	      try {
	        loader.init && loader.init(botpress, mod.configuration);
	      } catch (err) {
	        logger.warn('Error during module initialization: ', err);
	      }
	
	      loadedModules[mod.name] = mod;
	      logger.info('Loaded ' + mod.name + ', version ' + mod.version);
	      loadedCount++;
	    });
	
	    if (loadedCount > 0) {
	      logger.info('Loaded ' + loadedCount + ' modules');
	    }
	
	    return loadedModules;
	  };
	
	  var scanModules = function scanModules() {
	    var packagePath = _path2.default.join(projectLocation, 'package.json');
	
	    if (!_fs2.default.existsSync(packagePath)) {
	      return logger.warn('No package.json found at project root, ' + 'which means botpress can\'t load any module for the bot.');
	    }
	
	    var botPackage = eval('require')(packagePath);
	
	    var deps = botPackage.dependencies || {};
	    if (_util.isDeveloping) {
	      deps = _lodash2.default.merge(deps, botPackage.devDependencies || {});
	    }
	
	    return _lodash2.default.reduce(deps, function (result, value, key) {
	      if (!/^botpress-/i.test(key)) {
	        return result;
	      }
	      var entry = (0, _util.resolveFromDir)(projectLocation, key);
	      if (!entry) {
	        return result;
	      }
	      var root = (0, _util.resolveModuleRootPath)(entry);
	      if (!root) {
	        return result;
	      }
	
	      var modulePackage = eval('require')(_path2.default.join(root, 'package.json'));
	      if (!modulePackage.botpress) {
	        return result;
	      }
	
	      return result.push({
	        name: key,
	        root: root,
	        homepage: modulePackage.homepage,
	        settings: modulePackage.botpress,
	        version: modulePackage.version,
	        entry: entry
	      }) && result;
	    }, []);
	  };
	
	  var getRandomCommunityHero = _bluebird2.default.method(function () {
	    var modulesCachePath = _path2.default.join(dataLocation, './modules-cache.json');
	
	    return listAllCommunityModules().then(function () {
	      var _JSON$parse = JSON.parse(_fs2.default.readFileSync(modulesCachePath)),
	          modules = _JSON$parse.modules;
	
	      var module = _lodash2.default.sample(modules);
	
	      if (!module) {
	        return {
	          username: 'danyfs',
	          github: 'https://github.com/danyfs',
	          avatar: 'https://avatars1.githubusercontent.com/u/5629987?v=3',
	          contributions: 'many',
	          module: 'botpress'
	        };
	      }
	
	      var hero = _lodash2.default.sample(module.contributors);
	
	      return {
	        username: hero.login,
	        github: hero.html_url,
	        avatar: hero.avatar_url,
	        contributions: hero.contributions,
	        module: module.name
	      };
	    });
	  });
	
	  var mapModuleList = function mapModuleList(modules) {
	    var installed = listInstalledModules();
	    return modules.map(function (mod) {
	      return {
	        name: mod.name,
	        stars: mod.github.stargazers_count,
	        forks: mod.github.forks_count,
	        docLink: mod.homepage,
	        version: mod['dist-tags'].latest,
	        keywords: mod.keywords,
	        fullName: mod.github.full_name,
	        updated: mod.github.updated_at,
	        issues: mod.github.open_issues_count,
	        icon: mod.package.botpress.menuIcon,
	        description: mod.description,
	        installed: _lodash2.default.includes(installed, mod.name),
	        license: mod.license,
	        author: !mod.author.name ? mod.author : mod.author.name,
	        title: mod.title,
	        category: mod.category,
	        featured: mod.featured,
	        popular: mod.popular,
	        official: mod.official
	      };
	    });
	  };
	
	  var listAllCommunityModules = _bluebird2.default.method(function () {
	
	    if (!_fs2.default) {
	      return []; // TODO Fetch & return
	    }
	
	    var modulesCachePath = _path2.default.join(dataLocation, './modules-cache.json');
	    if (!_fs2.default.existsSync(modulesCachePath)) {
	      _fs2.default.writeFileSync(modulesCachePath, JSON.stringify({
	        modules: [],
	        updated: null
	      }));
	    }
	
	    var _JSON$parse2 = JSON.parse(_fs2.default.readFileSync(modulesCachePath)),
	        modules = _JSON$parse2.modules,
	        updated = _JSON$parse2.updated;
	
	    if (updated && (0, _moment2.default)().diff((0, _moment2.default)(updated), 'minutes') <= 30) {
	      return mapModuleList(modules);
	    }
	
	    return _bluebird2.default.props({
	      newModules: fetchAllModules()
	    }).then(function (_ref2) {
	      var newModules = _ref2.newModules;
	
	
	      if (!newModules || !newModules.length) {
	        if (modules.length > 0) {
	          logger.debug('Fetched invalid modules. Report this to the Botpress Team.');
	          return mapModuleList(modules);
	        } else {
	          newModules = newModules || [];
	        }
	      }
	
	      _fs2.default.writeFileSync(modulesCachePath, JSON.stringify({
	        modules: newModules,
	        updated: new Date()
	      }));
	
	      return mapModuleList(newModules);
	    });
	  });
	
	  var resolveModuleNames = function resolveModuleNames(names) {
	    return names.map(function (name) {
	      if (!name || typeof name !== 'string') {
	        throw new TypeError('Expected module name to be a string');
	      }
	
	      var basename = _path2.default.basename(name);
	      var prefix = '';
	
	      if (basename !== name) {
	        prefix = name.substr(0, name.length - basename.length - 1);
	      }
	
	      if (basename.replace(/botpress-?/i, '').length === 0) {
	        throw new Error('Invalid module name: ' + basename);
	      }
	
	      if (!/^botpress-/i.test(basename)) {
	        basename = 'botpress-' + basename;
	      }
	
	      return prefix + basename;
	    });
	  };
	
	  var runSpawn = function runSpawn(command) {
	    return new _bluebird2.default(function (resolve, reject) {
	      command.stdout.on('data', function (data) {
	        log('info', data.toString());
	      });
	
	      command.stderr.on('data', function (data) {
	        log('error', data.toString());
	      });
	
	      command.on('close', function (code) {
	        if (code > 0) {
	          reject();
	        } else {
	          resolve();
	        }
	      });
	    });
	  };
	
	  var installModules = _bluebird2.default.method(function () {
	    for (var _len2 = arguments.length, names = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	      names[_key2] = arguments[_key2];
	    }
	
	    var modules = resolveModuleNames(names);
	
	    var install = (0, _child_process.spawn)(_util.npmCmd, ['install', '--save'].concat(_toConsumableArray(modules)), {
	      cwd: projectLocation
	    });
	
	    log('info', 'Installing modules: ' + modules.join(', '));
	
	    return runSpawn(install).then(function () {
	      return log('success', 'Modules successfully installed');
	    }).catch(function (err) {
	      log('error', 'An error occured during modules installation.');
	      throw err;
	    });
	  });
	
	  var uninstallModules = _bluebird2.default.method(function () {
	    for (var _len3 = arguments.length, names = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	      names[_key3] = arguments[_key3];
	    }
	
	    var modules = resolveModuleNames(names);
	    var uninstall = (0, _child_process.spawn)(_util.npmCmd, ['uninstall', '--save'].concat(_toConsumableArray(modules)), {
	      cwd: projectLocation
	    });
	
	    log('info', 'Uninstalling modules: ' + modules.join(', '));
	
	    return runSpawn(uninstall).then(function () {
	      return log('success', 'Modules successfully removed');
	    }).catch(function (err) {
	      log('error', 'An error occured during modules removal.');
	      throw err;
	    });
	  });
	
	  var listInstalledModules = function listInstalledModules() {
	    var packagePath = (0, _util.resolveProjectFile)('package.json', projectLocation, true);
	
	    var _JSON$parse3 = JSON.parse(_fs2.default.readFileSync(packagePath)),
	        dependencies = _JSON$parse3.dependencies;
	
	    var prodDeps = _lodash2.default.keys(dependencies);
	
	    return _lodash2.default.filter(prodDeps, function (dep) {
	      return (/botpress-.+/i.test(dep)
	      );
	    });
	  };
	
	  return {
	    listAllCommunityModules: listAllCommunityModules,
	    getRandomCommunityHero: getRandomCommunityHero,
	    install: installModules,
	    uninstall: uninstallModules,
	    listInstalled: listInstalledModules,
	    _scan: scanModules,
	    _load: loadModules
	  };
	};

/***/ },
/* 25 */
/***/ function(module, exports) {

	module.exports = require("bluebird");

/***/ },
/* 26 */
/***/ function(module, exports) {

	module.exports = require("axios");

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _lodash = __webpack_require__(12);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _fs = __webpack_require__(13);
	
	var _fs2 = _interopRequireDefault(_fs);
	
	var _path = __webpack_require__(3);
	
	var _path2 = _interopRequireDefault(_path);
	
	var _jsYaml = __webpack_require__(28);
	
	var _jsYaml2 = _interopRequireDefault(_jsYaml);
	
	var _bluebird = __webpack_require__(25);
	
	var _bluebird2 = _interopRequireDefault(_bluebird);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _bluebird2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _bluebird2.default.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	var validations = {
	  'any': function any(value, validation) {
	    return validation(value);
	  },
	  'string': function string(value, validation) {
	    return typeof value === 'string' && validation(value);
	  },
	  'choice': function choice(value, validation) {
	    return _lodash2.default.includes(validation, value);
	  },
	  'bool': function bool(value, validation) {
	    return (value === true || value === false) && validation(value);
	  }
	};
	
	var defaultValues = {
	  'any': null,
	  'string': '',
	  'bool': false
	};
	
	var amendOption = function amendOption(option, name) {
	
	  var validTypes = _lodash2.default.keys(validations);
	  if (!option.type || !_lodash2.default.includes(validTypes, option.type)) {
	    throw new Error('Invalid type (' + (option.type || '') + ') for config key (' + name + ')');
	  }
	
	  var validation = option.validation || function () {
	    return true;
	  };
	
	  if (typeof option.default !== 'undefined' && !validations[option.type](option.default, validation)) {
	    throw new Error('Invalid default value (' + option.default + ') for (' + name + ')');
	  }
	
	  if (!option.default && !_lodash2.default.includes(_lodash2.default.keys(defaultValues), option.type)) {
	    throw new Error('Default value is mandatory for type ' + option.type + ' (' + name + ')');
	  }
	
	  return {
	    type: option.type,
	    required: option.required || false,
	    env: option.env || null,
	    default: option.default || defaultValues[option.type],
	    validation: validation
	  };
	};
	
	var amendOptions = function amendOptions(options) {
	  return _lodash2.default.mapValues(options, amendOption);
	};
	
	var validateSet = function validateSet(options, name, value) {
	
	  // if name is not in options, throw
	  if (!_lodash2.default.includes(_lodash2.default.keys(options), name)) {
	    throw new Error('Unrecognized configuration key: ' + name);
	  }
	
	  if (!validations[options[name].type](value, options[name].validation)) {
	    throw new Error('Invalid value for key: ' + name);
	  }
	};
	
	var validateSave = function validateSave(options, object) {
	  var objKeys = _lodash2.default.keys(object);
	  var requiredKeys = _lodash2.default.filter(_lodash2.default.keys(options), function (key) {
	    return options[key].required;
	  });
	
	  _lodash2.default.each(requiredKeys, function (required) {
	    if (!_lodash2.default.includes(objKeys, required)) {
	      throw new Error('Missing required configuration: \'' + required + '\'');
	    }
	  });
	
	  _lodash2.default.each(objKeys, function (name) {
	    validateSet(options, name, object[name]);
	  });
	};
	
	var validateName = function validateName(name) {
	  if (!name || !/^[A-Z0-9._-]+$/i.test(name)) {
	    throw new Error('Invalid configuration name: ' + name + '. The name must only contain letters, _ and -');
	  }
	};
	
	var overwriteFromDefaultValues = function overwriteFromDefaultValues(options, object) {
	  _lodash2.default.each(_lodash2.default.keys(options), function (name) {
	    if (typeof object[name] === 'undefined') {
	      object[name] = options[name].default;
	    }
	  });
	
	  return object;
	};
	
	var overwriteFromEnvValues = function overwriteFromEnvValues(options, object) {
	  return _lodash2.default.mapValues(object, function (_v, name) {
	    if (options[name] && options[name].env && process.env[options[name].env]) {
	      return process.env[options[name].env];
	    }
	
	    return _v;
	  });
	};
	
	var overwriteFromBotfileValues = function overwriteFromBotfileValues(config_name, options, botfile, object) {
	  return _lodash2.default.mapValues(object, function (_v, name) {
	    if (botfile && botfile.config && botfile.config[config_name] && typeof botfile.config[config_name][name] !== 'undefined') {
	      return botfile.config[config_name][name];
	    }
	
	    return _v;
	  });
	};
	
	var overwriteFromConfigFileValues = function () {
	  var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(config_name, options, projectLocation, object) {
	    var configFilePath, configFromFile;
	    return regeneratorRuntime.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            if (projectLocation) {
	              _context.next = 2;
	              break;
	            }
	
	            return _context.abrupt('return', object);
	
	          case 2:
	            configFilePath = _path2.default.resolve(projectLocation, config_name + '.config.yml');
	
	            if (_fs2.default.existsSync(configFilePath)) {
	              _context.next = 5;
	              break;
	            }
	
	            return _context.abrupt('return', object);
	
	          case 5:
	            _context.next = 7;
	            return _bluebird2.default.fromCallback(function (callback) {
	              _jsYaml2.default.safeLoadAll(_fs2.default.readFileSync(configFilePath), function (value) {
	                return callback(null, value);
	              });
	            });
	
	          case 7:
	            configFromFile = _context.sent;
	            return _context.abrupt('return', _lodash2.default.mapValues(object, function (_v, name) {
	              if (typeof configFromFile[name] !== 'undefined') {
	                return configFromFile[name];
	              }
	              return _v;
	            }));
	
	          case 9:
	          case 'end':
	            return _context.stop();
	        }
	      }
	    }, _callee, undefined);
	  }));
	
	  return function overwriteFromConfigFileValues(_x, _x2, _x3, _x4) {
	    return _ref.apply(this, arguments);
	  };
	}();
	
	var removeUnusedKeys = function removeUnusedKeys(options, object) {
	  var final = {};
	
	  _lodash2.default.each(_lodash2.default.keys(options), function (name) {
	    if (typeof object[name] !== 'undefined') {
	      final[name] = object[name];
	    }
	  });
	
	  return final;
	};
	
	var createConfig = function createConfig(_ref2) {
	  var kvs = _ref2.kvs,
	      name = _ref2.name,
	      _ref2$botfile = _ref2.botfile,
	      botfile = _ref2$botfile === undefined ? {} : _ref2$botfile,
	      _ref2$options = _ref2.options,
	      options = _ref2$options === undefined ? {} : _ref2$options,
	      _ref2$projectLocation = _ref2.projectLocation,
	      projectLocation = _ref2$projectLocation === undefined ? null : _ref2$projectLocation;
	
	
	  if (!kvs || !kvs.get || !kvs.set) {
	    throw new Error('A valid \'kvs\' is mandatory to createConfig');
	  }
	
	  validateName(name);
	  options = amendOptions(options);
	
	  var saveAll = function saveAll(obj) {
	    validateSave(options, obj);
	    return kvs.set('__config', obj, name);
	  };
	
	  var loadAll = function loadAll() {
	    return kvs.get('__config', name).then(function (all) {
	      return overwriteFromDefaultValues(options, all || {});
	    }).then(function (all) {
	      return overwriteFromBotfileValues(name, options, botfile, all);
	    }).then(function (all) {
	      return overwriteFromConfigFileValues(name, options, projectLocation, all);
	    }).then(function (all) {
	      return overwriteFromEnvValues(options, all);
	    }).then(function (all) {
	      return removeUnusedKeys(options, all);
	    });
	  };
	
	  var get = function get(name) {
	    return kvs.get('__config', name + '.' + name).then(function (value) {
	      return overwriteFromDefaultValues(options, _defineProperty({}, name, value));
	    }).then(function (all) {
	      return overwriteFromBotfileValues(name, options, botfile, all);
	    }).then(function (all) {
	      return overwriteFromConfigFileValues(name, options, projectLocation, all);
	    }).then(function (all) {
	      return overwriteFromEnvValues(options, all);
	    }).then(function (obj) {
	      return obj[name];
	    });
	  };
	
	  var set = function set(name, value) {
	    validateSet(options, name, value);
	    return kvs.set('__config', value, name + '.' + name);
	  };
	
	  return { saveAll: saveAll, loadAll: loadAll, get: get, set: set, options: options };
	};
	
	module.exports = { createConfig: createConfig };

/***/ },
/* 28 */
/***/ function(module, exports) {

	module.exports = require("js-yaml");

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _util = __webpack_require__(14);
	
	var _util2 = _interopRequireDefault(_util);
	
	var _modules = __webpack_require__(24);
	
	var _modules2 = _interopRequireDefault(_modules);
	
	var _stats = __webpack_require__(16);
	
	var _stats2 = _interopRequireDefault(_stats);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	var waitingText = 'please wait, we are trying to uninstall the modules...';
	
	module.exports = function (module, modules) {
	  (0, _stats2.default)({}).track('cli', 'modules', 'install');
	  _util2.default.print('info', waitingText);
	  var modulesManager = (0, _modules2.default)(null, './', null);
	  modulesManager.uninstall.apply(modulesManager, [module].concat(_toConsumableArray(modules)));
	};

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _util = __webpack_require__(14);
	
	var _util2 = _interopRequireDefault(_util);
	
	var _stats = __webpack_require__(16);
	
	var _stats2 = _interopRequireDefault(_stats);
	
	var _fs = __webpack_require__(13);
	
	var _fs2 = _interopRequireDefault(_fs);
	
	var _path = __webpack_require__(3);
	
	var _path2 = _interopRequireDefault(_path);
	
	var _lodash = __webpack_require__(12);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _bluebird = __webpack_require__(25);
	
	var _bluebird2 = _interopRequireDefault(_bluebird);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = function (fromVersion) {
	  (0, _stats2.default)({}).track('cli', 'migration', fromVersion);
	
	  if (!_fs2.default.existsSync('./botfile.js')) {
	    throw new Error('You must be inside a bot directory to run a migration');
	  }
	
	  var files = _lodash2.default.sortBy(__webpack_require__(31).keys(), function (x) {
	    return x;
	  });
	
	  var toApply = _lodash2.default.filter(files, function (f) {
	    if (!/.js$/i.test(f)) {
	      return false;
	    }
	
	    return parseFloat(fromVersion) < parseFloat(f.replace(/\.js/i, ''));
	  });
	
	  return _bluebird2.default.mapSeries(toApply, function (file) {
	    var migration = __webpack_require__(31)("./" + file);
	    return migration(_path2.default.resolve('.')).then(function () {
	      _util2.default.print('success', 'Migration ' + file.replace('.js', '') + ' applied successfully');
	    });
	  }).finally(function () {
	    _util2.default.print('success', 'Migration completed.');
	    process.exit(0);
	  });
	};

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./0.1": 32,
		"./0.1.js": 32
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 31;


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _knex = __webpack_require__(33);
	
	var _knex2 = _interopRequireDefault(_knex);
	
	var _path = __webpack_require__(3);
	
	var _path2 = _interopRequireDefault(_path);
	
	var _fs = __webpack_require__(13);
	
	var _fs2 = _interopRequireDefault(_fs);
	
	var _kvs = __webpack_require__(34);
	
	var _kvs2 = _interopRequireDefault(_kvs);
	
	var _util = __webpack_require__(14);
	
	var _util2 = _interopRequireDefault(_util);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = function (bot_path) {
	  var botfilePath = _path2.default.join(bot_path, 'botfile.js');
	  var botfile = eval('require')(botfilePath);
	  var dbLocation = _path2.default.resolve(_path2.default.join(bot_path, botfile.dataDir, 'db.sqlite'));
	
	  return migrate_database_schema(dbLocation).then(function () {
	    return migrate_botfile(botfilePath);
	  });
	};
	
	function migrate_database_schema(dbLocation) {
	
	  var updateUsers = 'strftime(\'%Y-%m-%dT%H:%M:%fZ\', created_on/1000, \'unixepoch\')';
	
	  var knex = (0, _knex2.default)({
	    client: 'sqlite3',
	    connection: { filename: dbLocation },
	    useNullAsDefault: true
	  });
	
	  return knex.schema.table('users', function (table) {
	    table.string('picture_url');
	    table.string('first_name');
	    table.string('last_name');
	  }).then(function () {
	    return knex('users').update({ created_on: knex.raw(updateUsers) });
	  }).then(function (rows) {
	    _util2.default.print('info', 'Updated ' + rows + ' users');
	    _util2.default.print('warn', 'Users table was migrated to new schema but existing ' + 'users will miss the following fields: `picture_url`, `first_name`, ' + '`last_name`. They have been left to `null`.');
	  }).catch(function () {
	    _util2.default.print('warn', 'Did not migrate table `users` as schema was already up to date');
	  }).then(function () {
	    return (0, _kvs2.default)(knex).bootstrap();
	  }).catch(function () {
	    _util2.default.print('warn', 'Did not create table `kvs` as schema was already up to date');
	  }).then(function () {
	
	    if (!process.env.DELETE_TABLES) {
	      _util2.default.print('warn', "This migration must delete the tables of " + "the following modules: `botpress-scheduler`, `botpress-analytics`, " + "`botpress-hitl` and `botpress-subscription`.");
	
	      _util2.default.print('warn', "This step has been skipped because you didn't provide " + "the DELETE_TABLES=true environement variable.");
	
	      _util2.default.print('warn', "Please backup your data if necessary then re-run with DELETE_TABLES=true");
	      return false;
	    }
	
	    return dropTableIfExists(knex, 'analytics_interactions').then(function () {
	      return dropTableIfExists(knex, 'analytics_runs');
	    }).then(function () {
	      return dropTableIfExists(knex, 'broadcast_outbox');
	    }).then(function () {
	      return dropTableIfExists(knex, 'broadcast_schedules');
	    }).then(function () {
	      return dropTableIfExists(knex, 'hitl_messages');
	    }).then(function () {
	      return dropTableIfExists(knex, 'hitl_sessions');
	    }).then(function () {
	      return dropTableIfExists(knex, 'subscription_users');
	    }).then(function () {
	      return dropTableIfExists(knex, 'subscriptions');
	    }).then(function () {
	      return dropTableIfExists(knex, 'scheduler_schedules');
	    }).then(function () {
	      return dropTableIfExists(knex, 'scheduler_tasks');
	    }).then(function () {
	      return _util2.default.print('info', 'Dropped module tables');
	    });
	  });
	}
	
	function dropTableIfExists(knex, tableName) {
	  return knex.schema.hasTable(tableName).then(function (has) {
	    if (has) {
	      return knex.schema.dropTable(tableName);
	    }
	  });
	}
	
	function migrate_botfile(botfilePath) {
	  var before = _fs2.default.readFileSync(botfilePath).toString();
	
	  if (before.indexOf('postgres:') >= 0) {
	    _util2.default.print('warn', 'Did not migrate botfile as it seemed like `postgres`' + ' was already present. Please migrate manually if this is a mistake.');
	    return false;
	  }
	
	  var after = before.replace(/module\.exports.*?=.*?{/i, 'module.exports = {\n\n  /**\n  * Postgres configuration\n  */\n  postgres: {\n    enabled: process.env.DATABASE === \'postgres\',\n    host: process.env.PG_HOST || \'127.0.0.1\',\n    port: process.env.PG_PORT || 5432,\n    user: process.env.PG_USER || \'\',\n    password: process.env.PG_PASSWORD || \'\',\n    database: process.env.PG_DB || \'\'\n  },');
	
	  _fs2.default.writeFileSync(botfilePath, after);
	
	  _util2.default.print('info', 'Updated botfile');
	}

/***/ },
/* 33 */
/***/ function(module, exports) {

	module.exports = require("knex");

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _bluebird = __webpack_require__(25);
	
	var _bluebird2 = _interopRequireDefault(_bluebird);
	
	var _lodash = __webpack_require__(12);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _helpers = __webpack_require__(4);
	
	var _helpers2 = _interopRequireDefault(_helpers);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	  Possible options:
	    - betweenGetAndSetCallback: will be called between the get and the set
	    and wait for promise to resolve
	    - tableName: overrides the KVS table's name
	*/
	module.exports = function (knex) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	  var getSetCallback = options.betweenGetAndSetCallback || function () {
	    return _bluebird2.default.resolve();
	  };
	  var tableName = options.tableName || 'kvs';
	
	  var get = function get(key, path) {
	    return knex(tableName).where({ key: key }).limit(1).then().get(0).then(function (row) {
	      if (!row) {
	        return null;
	      }
	
	      var obj = JSON.parse(row.value);
	      if (!path) {
	        return obj;
	      }
	
	      return _lodash2.default.at(obj, [path])[0];
	    });
	  };
	
	  var set = function set(key, value, path) {
	    var now = (0, _helpers2.default)(knex).date.now();
	
	    var setValue = function setValue(obj) {
	      if (path) {
	        _lodash2.default.set(obj, path, value);
	        return obj;
	      } else {
	        return value;
	      }
	    };
	
	    return get(key).then(function (original) {
	      return getSetCallback().then(function () {
	        if (!_lodash2.default.isNil(original)) {
	          var newObj = setValue(Object.assign({}, original));
	          return knex(tableName).where({ key: key }).update({
	            value: JSON.stringify(newObj),
	            modified_on: now
	          }).then();
	        } else {
	          var obj = setValue({});
	          return knex(tableName).insert({
	            key: key,
	            value: JSON.stringify(obj),
	            modified_on: now
	          }).then();
	        }
	      });
	    });
	  };
	
	  var bootstrap = function bootstrap() {
	    return (0, _helpers2.default)(knex).createTableIfNotExists(tableName, function (table) {
	      table.string('key').primary();
	      table.text('value');
	      table.timestamp('modified_on');
	    });
	  };
	
	  return { get: get, set: set, bootstrap: bootstrap };
	};

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _util = __webpack_require__(14);
	
	var _modules = __webpack_require__(24);
	
	var _modules2 = _interopRequireDefault(_modules);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = function () {
	  var modulesManager = (0, _modules2.default)(null, './', null);
	  var modules = modulesManager.listInstalled();
	
	  if (!modules || modules.length === 0) {
	    (0, _util.print)('info', "There are no module installed.");
	    (0, _util.print)('------------------');
	    (0, _util.print)('info', "To install modules, use `botpress install <module-name>`");
	    (0, _util.print)('info', "You can discover modules in the Modules section of your bot UI" + ". You can also search npm with the botpress keyword.");
	  } else {
	    (0, _util.print)('info', "There are " + modules.length + " modules installed:");
	    modules.forEach(function (mod) {
	      return (0, _util.print)('>> ' + mod);
	    });
	  }
	};

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	__webpack_require__(37);
	
	var _chalk = __webpack_require__(11);
	
	var _chalk2 = _interopRequireDefault(_chalk);
	
	var _path = __webpack_require__(3);
	
	var _path2 = _interopRequireDefault(_path);
	
	var _fs = __webpack_require__(13);
	
	var _fs2 = _interopRequireDefault(_fs);
	
	var _lodash = __webpack_require__(12);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _cluster = __webpack_require__(38);
	
	var _cluster2 = _interopRequireDefault(_cluster);
	
	var _dotenv = __webpack_require__(39);
	
	var _dotenv2 = _interopRequireDefault(_dotenv);
	
	var _ServiceLocator = __webpack_require__(40);
	
	var _ServiceLocator2 = _interopRequireDefault(_ServiceLocator);
	
	var _bus = __webpack_require__(42);
	
	var _bus2 = _interopRequireDefault(_bus);
	
	var _middlewares = __webpack_require__(44);
	
	var _middlewares2 = _interopRequireDefault(_middlewares);
	
	var _logger = __webpack_require__(49);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var _security = __webpack_require__(51);
	
	var _security2 = _interopRequireDefault(_security);
	
	var _notifications = __webpack_require__(54);
	
	var _notifications2 = _interopRequireDefault(_notifications);
	
	var _hear = __webpack_require__(56);
	
	var _hear2 = _interopRequireDefault(_hear);
	
	var _fallback = __webpack_require__(57);
	
	var _fallback2 = _interopRequireDefault(_fallback);
	
	var _database = __webpack_require__(58);
	
	var _database2 = _interopRequireDefault(_database);
	
	var _licensing = __webpack_require__(46);
	
	var _licensing2 = _interopRequireDefault(_licensing);
	
	var _about = __webpack_require__(63);
	
	var _about2 = _interopRequireDefault(_about);
	
	var _modules = __webpack_require__(24);
	
	var _modules2 = _interopRequireDefault(_modules);
	
	var _umm = __webpack_require__(64);
	
	var _umm2 = _interopRequireDefault(_umm);
	
	var _users = __webpack_require__(70);
	
	var _users2 = _interopRequireDefault(_users);
	
	var _conversations = __webpack_require__(71);
	
	var _conversations2 = _interopRequireDefault(_conversations);
	
	var _stats = __webpack_require__(16);
	
	var _stats2 = _interopRequireDefault(_stats);
	
	var _package = __webpack_require__(72);
	
	var _package2 = _interopRequireDefault(_package);
	
	var _emails = __webpack_require__(73);
	
	var _emails2 = _interopRequireDefault(_emails);
	
	var _mediator = __webpack_require__(74);
	
	var _mediator2 = _interopRequireDefault(_mediator);
	
	var _server = __webpack_require__(75);
	
	var _server2 = _interopRequireDefault(_server);
	
	var _util = __webpack_require__(14);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var RESTART_EXIT_CODE = 107;
	
	var getDataLocation = function getDataLocation(dataDir, projectLocation) {
	  return dataDir && _path2.default.isAbsolute(dataDir) ? _path2.default.resolve(dataDir) : _path2.default.resolve(projectLocation, dataDir || 'data');
	};
	
	var mkdirIfNeeded = function mkdirIfNeeded(path, logger) {
	  if (!_fs2.default.existsSync(path)) {
	    logger.info('Creating data directory: ' + path);
	
	    try {
	      _fs2.default.mkdirSync(path);
	    } catch (err) {
	      logger.error('[FATAL] Error creating directory: ' + err.message);
	      process.exit(1);
	    }
	  }
	};
	
	/**
	 * Global context botpress
	*/
	
	var botpress = function () {
	  /**
	   * Create botpress
	   *
	   * @param {string} obj.botfile - the config path
	   */
	  function botpress(_ref) {
	    var botfile = _ref.botfile;
	
	    _classCallCheck(this, botpress);
	
	    this.version = (0, _util.getBotpressVersion)();
	    /**
	     * The project location, which is the folder where botfile.js located
	     */
	    this.projectLocation = _path2.default.dirname(botfile);
	
	    /**
	     * The botfile config object
	     */
	    this.botfile = eval('require')(botfile);
	
	    this.stats = (0, _stats2.default)(this.botfile);
	
	    this.interval = null;
	  }
	
	  /**
	   * Start the bot instance
	   *
	   * It will do the following initiation steps:
	   *
	   * 1. setup logger
	   * 2. resolve paths (dataLocation)
	   * 3. inject security functions
	   * 4. load modules
	   */
	
	
	  _createClass(botpress, [{
	    key: '_start',
	    value: function _start() {
	      var _this = this;
	
	      this.stats.track('bot', 'started');
	
	      if (!this.interval) {
	        this.inverval = setInterval(function () {
	          _this.stats.track('bot', 'running');
	        }, 30 * 1000);
	      }
	
	      // change the current working directory to botpress's installation path
	      // the bot's location is kept in this.projectLocation
	      process.chdir(_path2.default.join(__dirname, '../'));
	
	      var projectLocation = this.projectLocation,
	          botfile = this.botfile;
	
	
	      var envPath = _path2.default.resolve(projectLocation, '.env');
	      if (_fs2.default.existsSync(envPath)) {
	        var envConfig = _dotenv2.default.parse(_fs2.default.readFileSync(envPath));
	        for (var k in envConfig) {
	          if (_lodash2.default.isNil(process.env[k]) || process.env.ENV_OVERLOAD) {
	            process.env[k] = envConfig[k];
	          }
	        }
	      }
	
	      var isFirstRun = _fs2.default.existsSync(_path2.default.join(projectLocation, '.welcome'));
	      var dataLocation = getDataLocation(botfile.dataDir, projectLocation);
	      var modulesConfigDir = getDataLocation(botfile.modulesConfigDir, projectLocation);
	      var dbLocation = _path2.default.join(dataLocation, 'db.sqlite');
	      var version = _package2.default.version;
	
	      var logger = (0, _logger2.default)(dataLocation, botfile.log);
	      mkdirIfNeeded(dataLocation, logger);
	      mkdirIfNeeded(modulesConfigDir, logger);
	
	      logger.info('Starting botpress version ' + version);
	
	      var db = (0, _database2.default)({
	        sqlite: { location: dbLocation },
	        postgres: botfile.postgres
	      });
	
	      var security = (0, _security2.default)({
	        dataLocation: dataLocation,
	        securityConfig: botfile.login,
	        db: db
	      });
	
	      var modules = (0, _modules2.default)(logger, projectLocation, dataLocation, db.kvs);
	
	      var moduleDefinitions = modules._scan();
	
	      var events = new _bus2.default();
	      var notifications = (0, _notifications2.default)(dataLocation, botfile.notification, moduleDefinitions, events, logger);
	      var about = (0, _about2.default)(projectLocation);
	      var licensing = (0, _licensing2.default)({ logger: logger, projectLocation: projectLocation, version: version, db: db, botfile: botfile });
	      var middlewares = (0, _middlewares2.default)(this, dataLocation, projectLocation, logger);
	
	      var _createHearMiddleware = (0, _hear2.default)(),
	          hear = _createHearMiddleware.hear,
	          hearMiddleware = _createHearMiddleware.middleware;
	
	      var _createFallbackMiddle = (0, _fallback2.default)(this),
	          fallbackMiddleware = _createFallbackMiddle.middleware;
	
	      var emails = (0, _emails2.default)({ emailConfig: botfile.emails });
	      var mediator = (0, _mediator2.default)(this);
	      var convo = (0, _conversations2.default)({ logger: logger, middleware: middlewares });
	      var umm = (0, _umm2.default)({ logger: logger, middlewares: middlewares, projectLocation: projectLocation, botfile: botfile, db: db });
	      var users = (0, _users2.default)({ db: db });
	
	      middlewares.register(umm.incomingMiddleware);
	      middlewares.register(hearMiddleware);
	      middlewares.register(fallbackMiddleware);
	
	      _lodash2.default.assign(this, {
	        dataLocation: dataLocation,
	        isFirstRun: isFirstRun,
	        version: version,
	        logger: logger,
	        security: security, // login, authenticate, getSecret
	        events: events,
	        notifications: notifications, // load, save, send
	        about: about,
	        middlewares: middlewares,
	        hear: hear,
	        licensing: licensing,
	        modules: modules,
	        db: db,
	        emails: emails,
	        mediator: mediator,
	        convo: convo,
	        umm: umm,
	        users: users
	      });
	
	      _ServiceLocator2.default.init({ bp: this });
	
	      var loadedModules = modules._load(moduleDefinitions, this);
	
	      this.stats.track('bot', 'modules', 'loaded', loadedModules.length);
	
	      _lodash2.default.assign(this, {
	        _loadedModules: loadedModules
	      });
	
	      mediator.install();
	
	      var server = (0, _server2.default)(this);
	      server.start().then(function () {
	        events.emit('ready');
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;
	
	        try {
	          for (var _iterator = _lodash2.default.values(loadedModules)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var mod = _step.value;
	
	            mod.handlers.ready && mod.handlers.ready(_this, mod.configuration);
	          }
	        } catch (err) {
	          _didIteratorError = true;
	          _iteratorError = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	              _iterator.return();
	            }
	          } finally {
	            if (_didIteratorError) {
	              throw _iteratorError;
	            }
	          }
	        }
	
	        var port = botfile.port;
	
	        logger.info(_chalk2.default.green.bold('Bot launched. Visit: http://localhost:' + port));
	      });
	
	      var middlewareAutoLoading = _lodash2.default.get(botfile, 'middleware.autoLoading');
	      if (!_lodash2.default.isNil(middlewareAutoLoading) && middlewareAutoLoading === false) {
	        logger.debug('Middleware Auto Loading was disabled. Call bp.middlewares.load() manually.');
	      } else {
	        middlewares.load();
	      }
	
	      var projectEntry = eval('require')(projectLocation);
	      if (typeof projectEntry === 'function') {
	        projectEntry.call(projectEntry, this);
	      } else {
	        logger.error('[FATAL] The bot entry point must be a function that takes an instance of bp');
	        process.exit(1);
	      }
	
	      process.on('uncaughtException', function (err) {
	        logger.error('[FATAL] An unhandled exception occured in your bot', err);
	        if (_util.isDeveloping) {
	          logger.error(err.stack);
	        }
	
	        _this.stats.trackException(err.message);
	        process.exit(1);
	      });
	
	      process.on('unhandledRejection', function (reason, p) {
	        logger.error('Unhandled Rejection in Promise: ', p, 'Reason:', reason);
	
	        _this.stats.trackException(reason);
	        if (_util.isDeveloping && reason && reason.stack) {
	          logger.error(reason.stack);
	        }
	      });
	    }
	  }, {
	    key: 'start',
	    value: function start() {
	      var _this2 = this;
	
	      if (_cluster2.default.isMaster) {
	        _cluster2.default.fork();
	
	        _cluster2.default.on('exit', function (worker, code /* , signal */) {
	          if (code === RESTART_EXIT_CODE) {
	            _cluster2.default.fork();
	
	            _this2.stats.track('bot', 'restarted');
	            (0, _util.print)('info', '*** restarted worker process ***');
	          } else {
	            process.exit(code);
	          }
	        });
	      }
	
	      if (_cluster2.default.isWorker) {
	        this._start();
	      }
	    }
	  }, {
	    key: 'restart',
	    value: function restart() {
	      var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	
	      setTimeout(function () {
	        process.exit(RESTART_EXIT_CODE);
	      }, interval);
	    }
	  }]);
	
	  return botpress;
	}();
	
	module.exports = botpress;

/***/ },
/* 37 */
/***/ function(module, exports) {

	module.exports = require("source-map-support/register");

/***/ },
/* 38 */
/***/ function(module, exports) {

	module.exports = require("cluster");

/***/ },
/* 39 */
/***/ function(module, exports) {

	module.exports = require("dotenv");

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var init = function () {
	  var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(obj) {
	    return regeneratorRuntime.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            if (initPromise.isFulfilled()) {
	              _context.next = 8;
	              break;
	            }
	
	            resolveInit();
	            _context.t0 = Object;
	            _context.t1 = _services;
	            _context.next = 6;
	            return (0, _services3.default)(obj);
	
	          case 6:
	            _context.t2 = _context.sent;
	
	            _context.t0.assign.call(_context.t0, _context.t1, _context.t2);
	
	          case 8:
	          case 'end':
	            return _context.stop();
	        }
	      }
	    }, _callee, this);
	  }));
	
	  return function init(_x) {
	    return _ref.apply(this, arguments);
	  };
	}();
	
	var getService = function () {
	  var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(name) {
	    var throwIfNotFound = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	    return regeneratorRuntime.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            _context2.next = 2;
	            return initPromise.timeout(5000).catch(function (err) {
	              throw new Error('ServiceLocator was not initialized');
	            });
	
	          case 2:
	            if (!(throwIfNotFound && !_services[name])) {
	              _context2.next = 4;
	              break;
	            }
	
	            throw new Error('Service \'' + name + '\' not registered');
	
	          case 4:
	            return _context2.abrupt('return', _services[name]);
	
	          case 5:
	          case 'end':
	            return _context2.stop();
	        }
	      }
	    }, _callee2, this);
	  }));
	
	  return function getService(_x2) {
	    return _ref2.apply(this, arguments);
	  };
	}();
	
	var _bluebird = __webpack_require__(25);
	
	var _bluebird2 = _interopRequireDefault(_bluebird);
	
	var _services2 = __webpack_require__(41);
	
	var _services3 = _interopRequireDefault(_services2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _bluebird2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _bluebird2.default.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	var _services = {};
	var resolveInit = false;
	
	var initPromise = new _bluebird2.default(function (resolve) {
	  resolveInit = resolve;
	});
	
	function registerService(name, fn) {
	  if (!!_services[name]) {
	    throw new Error('Service \'' + name + '\' has already been set');
	  }
	
	  _services[name] = fn;
	}
	
	module.exports = { init: init, registerService: registerService, getService: getService };

/***/ },
/* 41 */
/***/ function(module, exports) {

	"use strict";
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	module.exports = function () {
	  var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(_ref2) {
	    var bp = _ref2.bp;
	    return regeneratorRuntime.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, _callee, undefined);
	  }));
	
	  return function (_x) {
	    return _ref.apply(this, arguments);
	  };
	}();

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _eventemitter = __webpack_require__(43);
	
	var _eventemitter2 = _interopRequireDefault(_eventemitter);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var EventBus = function (_EventEmitter) {
	  _inherits(EventBus, _EventEmitter);
	
	  function EventBus() {
	    _classCallCheck(this, EventBus);
	
	    return _possibleConstructorReturn(this, (EventBus.__proto__ || Object.getPrototypeOf(EventBus)).call(this, {
	      wildcard: true,
	      maxListeners: 100
	    }));
	  }
	
	  return EventBus;
	}(_eventemitter2.default);
	
	module.exports = EventBus;

/***/ },
/* 43 */
/***/ function(module, exports) {

	module.exports = require("eventemitter2");

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _lodash = __webpack_require__(12);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _mware = __webpack_require__(45);
	
	var _mware2 = _interopRequireDefault(_mware);
	
	var _path = __webpack_require__(3);
	
	var _path2 = _interopRequireDefault(_path);
	
	var _fs = __webpack_require__(13);
	
	var _fs2 = _interopRequireDefault(_fs);
	
	var _bluebird = __webpack_require__(25);
	
	var _bluebird2 = _interopRequireDefault(_bluebird);
	
	var _licensing = __webpack_require__(46);
	
	var _licensing2 = _interopRequireDefault(_licensing);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var createMiddleware = function createMiddleware(bp, middlewareName) {
	  var _use = (0, _mware2.default)();
	  var _error = (0, _mware2.default)();
	
	  var use = function use(middleware) {
	    if (typeof middleware !== 'function') {
	      throw new TypeError('Expected all middleware arguments to be functions');
	    }
	
	    if (middleware.length === 2) {
	      _use(middleware);
	    } else if (middleware.length === 3) {
	      _error(middleware);
	    }
	  };
	
	  var dispatch = function dispatch(event) {
	    if (!_lodash2.default.isPlainObject(event)) {
	      throw new TypeError('Expected all dispatch arguments to be plain event objects');
	    }
	
	    var conformity = {
	      type: function type(value) {
	        return typeof value === 'string';
	      },
	      platform: function platform(value) {
	        return typeof value === 'string';
	      },
	      text: function text(value) {
	        return typeof value === 'string';
	      },
	      raw: function raw() {
	        return true;
	      }
	    };
	
	    if (!_lodash2.default.conformsTo(event, conformity)) {
	      throw new TypeError('Expected event to contain (type: string), ' + '(platform: string), (text: string), (raw: any)');
	    }
	
	    // Provide botpress to the event handlers
	    event.bp = bp;
	
	    _use.run(event, function (err) {
	      if (err) {
	        _error.run(err, event, function () {
	          bp.logger.error('[BOTPRESS] Unhandled error in middleware (' + middlewareName + '). Error: ' + err.message);
	        });
	      }
	    });
	
	    return event._promise || _bluebird2.default.resolve();
	  };
	
	  return { use: use, dispatch: dispatch };
	};
	
	module.exports = function (bp, dataLocation, projectLocation, logger) {
	  var middlewaresFilePath = _path2.default.join(dataLocation, 'middlewares.json');
	  var incoming = void 0,
	      outgoing = void 0,
	      middlewares = void 0,
	      customizations = void 0;
	
	  var noopChain = function noopChain() {
	    var message = 'Middleware called before middlewares have been loaded. This is a no-op.' + ' Have you forgotten to call `bp.loadMiddlewares()` in your bot?';
	
	    if (arguments && _typeof(arguments[0]) === 'object') {
	      message += '\nCalled with: ' + JSON.stringify(arguments[0], null, 2);
	    }
	
	    logger.warn(message);
	  };
	
	  var readCustomizations = function readCustomizations() {
	    if (!_fs2.default.existsSync(middlewaresFilePath)) {
	      _fs2.default.writeFileSync(middlewaresFilePath, '{}');
	    }
	    return JSON.parse(_fs2.default.readFileSync(middlewaresFilePath));
	  };
	
	  var writeCustomizations = function writeCustomizations() {
	    _fs2.default.writeFileSync(middlewaresFilePath, JSON.stringify(customizations));
	  };
	
	  var setCustomizations = function setCustomizations(middlewares) {
	    _lodash2.default.each(middlewares, function (middleware) {
	      var name = middleware.name,
	          order = middleware.order,
	          enabled = middleware.enabled;
	
	      customizations[name] = { order: order, enabled: enabled };
	    });
	    writeCustomizations();
	  };
	
	  var resetCustomizations = function resetCustomizations() {
	    customizations = {};
	    writeCustomizations();
	  };
	
	  var register = function register(middleware) {
	    if (!middleware || !middleware.name) {
	      logger.error('A unique middleware name is mandatory');
	      return false;
	    }
	
	    if (!middleware.handler) {
	      logger.error('A middleware handler is mandatory');
	      return false;
	    }
	
	    if (!middleware.type || middleware.type !== 'incoming' && middleware.type !== 'outgoing') {
	      logger.error('A middleware type (incoming or outgoing) is required');
	      return false;
	    }
	
	    middleware.order = middleware.order || 0;
	    middleware.enabled = typeof middleware.enabled === 'undefined' ? true : !!middleware.enabled;
	
	    if (_lodash2.default.some(middlewares, function (m) {
	      return m.name === middleware.name;
	    })) {
	      logger.error('Another middleware with the same name has already been registered');
	      return false;
	    }
	
	    middlewares.push(middleware);
	  };
	
	  var list = function list() {
	    return _lodash2.default.orderBy(middlewares.map(function (middleware) {
	      var customization = customizations[middleware.name];
	      if (customization) {
	        return Object.assign({}, middleware, customization);
	      }
	      return middleware;
	    }), 'order');
	  };
	
	  var load = function load() {
	    incoming = createMiddleware(bp, 'incoming');
	    outgoing = createMiddleware(bp, 'outgoing');
	
	    var licenseMiddleware = bp.licensing.middleware;
	
	    incoming.use(licenseMiddleware);
	
	    _lodash2.default.each(list(), function (m) {
	      if (!m.enabled) {
	        return logger.debug('SKIPPING middleware:', m.name, ' [Reason=disabled]');
	      }
	
	      logger.debug('Loading middleware:', m.name);
	
	      if (m.type === 'incoming') {
	        incoming.use(m.handler);
	      } else {
	        outgoing.use(m.handler);
	      }
	    });
	  };
	
	  var sendToMiddleware = function sendToMiddleware(type) {
	    return function (event) {
	      var mw = type === 'incoming' ? incoming : outgoing;
	      return mw.dispatch ? mw.dispatch(event) : mw(event);
	    };
	  };
	
	  var sendIncoming = sendToMiddleware('incoming');
	  var sendOutgoing = sendToMiddleware('outgoing');
	
	  incoming = outgoing = noopChain;
	  middlewares = [];
	  customizations = readCustomizations();
	
	  return {
	    load: load,
	    list: list,
	    register: register,
	    sendIncoming: sendIncoming,
	    sendOutgoing: sendOutgoing,
	    getCustomizations: function getCustomizations() {
	      return customizations;
	    },
	    setCustomizations: setCustomizations,
	    resetCustomizations: resetCustomizations
	  };
	};

/***/ },
/* 45 */
/***/ function(module, exports) {

	module.exports = require("mware");

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _path = __webpack_require__(3);
	
	var _path2 = _interopRequireDefault(_path);
	
	var _fs = __webpack_require__(13);
	
	var _fs2 = _interopRequireDefault(_fs);
	
	var _bluebird = __webpack_require__(25);
	
	var _bluebird2 = _interopRequireDefault(_bluebird);
	
	var _lodash = __webpack_require__(12);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _listeners = __webpack_require__(47);
	
	var _listeners2 = _interopRequireDefault(_listeners);
	
	var _util = __webpack_require__(14);
	
	var _license = __webpack_require__(48);
	
	var _license2 = _interopRequireDefault(_license);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _bluebird2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _bluebird2.default.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	module.exports = function (_ref) {
	  var logger = _ref.logger,
	      version = _ref.version,
	      projectLocation = _ref.projectLocation,
	      db = _ref.db,
	      botfile = _ref.botfile;
	
	
	  var licensesPath = _path2.default.join(__dirname, '../licenses');
	
	  var getLicenses = function getLicenses() {
	    var packageJsonPath = (0, _util.resolveProjectFile)('package.json', projectLocation, true);
	
	    var _JSON$parse = JSON.parse(_fs2.default.readFileSync(packageJsonPath)),
	        license = _JSON$parse.license;
	
	    var agplContent = _fs2.default.readFileSync(_path2.default.join(licensesPath, 'LICENSE_AGPL3')).toString();
	    var botpressContent = _fs2.default.readFileSync(_path2.default.join(licensesPath, 'LICENSE_BOTPRESS')).toString();
	
	    return {
	      agpl: {
	        name: 'AGPL-3.0',
	        licensedUnder: license === 'AGPL-3.0',
	        text: agplContent
	      },
	      botpress: {
	        name: 'Botpress',
	        licensedUnder: license.toLowerCase().indexOf('botpress') >= 0,
	        text: botpressContent
	      }
	    };
	  };
	
	  var changeLicense = _bluebird2.default.method(function (license) {
	    var packageJsonPath = (0, _util.resolveProjectFile)('package.json', projectLocation, true);
	
	    var licensePath = (0, _util.resolveProjectFile)('LICENSE', projectLocation, true);
	    var licenseFileName = license === 'AGPL-3.0' ? 'LICENSE_AGPL3' : 'LICENSE_BOTPRESS';
	    var licenseContent = _fs2.default.readFileSync(_path2.default.join(licensesPath, licenseFileName));
	
	    var pkg = JSON.parse(_fs2.default.readFileSync(packageJsonPath));
	    pkg.license = license;
	
	    _fs2.default.writeFileSync(licensePath, licenseContent);
	    _fs2.default.writeFileSync(packageJsonPath, JSON.stringify(pkg, null, 2));
	  });
	
	  var middleware = _listeners2.default.hear(/^BOT_LICENSE$/, function (event, next) {
	    var packageJsonPath = (0, _util.resolveProjectFile)('package.json', projectLocation, true);
	
	    var _JSON$parse2 = JSON.parse(_fs2.default.readFileSync(packageJsonPath)),
	        license = _JSON$parse2.license,
	        name = _JSON$parse2.name,
	        author = _JSON$parse2.author;
	
	    var bp = event.bp;
	
	    var response = 'Bot:  ' + name + '\nCreated by: ' + author + '\nLicense: ' + license + '\nBotpress: ' + bp.version;
	
	    var userId = event.user && event.user.id;
	
	    if (bp[event.platform] && bp[event.platform].sendText) {
	      bp[event.platform].sendText(userId, response);
	    } else {
	      bp.middlewares.sendOutgoing({
	        platform: event.platform,
	        type: 'text',
	        text: response,
	        raw: {
	          to: userId,
	          message: response,
	          responseTo: event
	        }
	      });
	    }
	  });
	
	  var guard = (0, _license2.default)(logger, db, botfile);
	  guard.start();
	
	  return {
	    getLicensing: function () {
	      var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	        var licenses, currentLicense;
	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                licenses = getLicenses();
	                currentLicense = _lodash2.default.find(licenses, { licensedUnder: true });
	
	                currentLicense = currentLicense || licenses.botpress;
	
	                _context.t0 = Object;
	                _context.next = 6;
	                return guard.getStatus();
	
	              case 6:
	                _context.t1 = _context.sent;
	                _context.t2 = {
	                  text: currentLicense.text
	                };
	                return _context.abrupt('return', _context.t0.assign.call(_context.t0, _context.t1, _context.t2));
	
	              case 9:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, undefined);
	      }));
	
	      return function getLicensing() {
	        return _ref2.apply(this, arguments);
	      };
	    }(),
	    changeLicense: changeLicense,
	    middleware: middleware,
	    getFeatures: guard.getFeatures
	  };
	};

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _lodash = __webpack_require__(12);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var matches = function matches(conditions, event) {
	  if (!_lodash2.default.isPlainObject(conditions)) {
	    conditions = { text: conditions };
	  }
	
	  var pairs = _lodash2.default.toPairs(conditions);
	  return _lodash2.default.every(pairs, function (_ref) {
	    var _ref2 = _slicedToArray(_ref, 2),
	        key = _ref2[0],
	        comparrer = _ref2[1];
	
	    var eventValue = _lodash2.default.get(event, key, null);
	
	    if (_lodash2.default.isFunction(comparrer)) {
	      return comparrer(eventValue, event) === true;
	    } else if (_lodash2.default.isRegExp(comparrer)) {
	      var _matches = comparrer.test(eventValue);
	
	      if (_matches && _lodash2.default.isString(eventValue)) {
	        if (_lodash2.default.isNil(event.captured)) {
	          event.captured = [];
	        }
	
	        var a = _lodash2.default.tail(comparrer.exec(eventValue));
	        a.forEach(function (m) {
	          return event.captured.push(m);
	        });
	      }
	
	      return _matches;
	    } else {
	      return _lodash2.default.isEqual(comparrer, eventValue);
	    }
	  });
	};
	
	var hear = function hear(conditions, callback) {
	  return function (event, next) {
	    var result = matches(conditions, event);
	
	    if (result && _lodash2.default.isFunction(callback)) {
	      if (callback.length <= 1) {
	        if (_lodash2.default.isFunction(next)) {
	          next();
	        }
	        callback(event);
	      } else {
	        callback(event, next);
	      }
	    } else {
	      if (_lodash2.default.isFunction(next)) {
	        next();
	      }
	    }
	  };
	};
	
	module.exports = { hear: hear, matches: matches };

/***/ },
/* 48 */
/***/ function(module, exports) {

	'use strict';
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	module.exports = function (logger, db, botfile) {
	  return {
	    // There is no License Guard in the Open-Source / Free version
	    start: function start() {},
	    getStatus: function () {
	      var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                return _context.abrupt('return', {
	                  licensed: true,
	                  name: 'Botpress Community',
	                  text: null,
	                  status: 'Active'
	                });
	
	              case 1:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, undefined);
	      }));
	
	      return function getStatus() {
	        return _ref.apply(this, arguments);
	      };
	    }(),
	    getFeatures: function getFeatures() {
	      return {};
	    }
	  };
	};

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _winston = __webpack_require__(50);
	
	var _winston2 = _interopRequireDefault(_winston);
	
	var _path = __webpack_require__(3);
	
	var _path2 = _interopRequireDefault(_path);
	
	var _bluebird = __webpack_require__(25);
	
	var _bluebird2 = _interopRequireDefault(_bluebird);
	
	var _moment = __webpack_require__(5);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _util = __webpack_require__(14);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = function (dataLocation, logConfig) {
	  var logger = new _winston2.default.Logger({
	    level: _util.isDeveloping ? 'debug' : 'info',
	    transports: [new _winston2.default.transports.Console({
	      prettyPrint: true,
	      colorize: true,
	      timestamp: function timestamp() {
	        return (0, _moment2.default)().format('HH:mm:ss');
	      }
	    })]
	  });
	
	  logger.enableFileTransport = function () {
	    var logFile = _path2.default.join(dataLocation, logConfig.file);
	    logger.add(_winston2.default.transports.File, {
	      filename: logFile,
	      maxsize: logConfig.maxSize
	    });
	  };
	
	  logger.archiveToFile = function () {
	    var logFile = _path2.default.join(dataLocation, logConfig.file);
	
	    return _bluebird2.default.resolve(logFile);
	  };
	
	  if (!logConfig.disableFileLogs) {
	    logger.enableFileTransport();
	  }
	
	  return logger;
	};

/***/ },
/* 50 */
/***/ function(module, exports) {

	module.exports = require("winston");

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _jsonwebtoken = __webpack_require__(52);
	
	var _jsonwebtoken2 = _interopRequireDefault(_jsonwebtoken);
	
	var _lodash = __webpack_require__(12);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _authentication = __webpack_require__(53);
	
	var _authentication2 = _interopRequireDefault(_authentication);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	/**
	 * Security helper for botpress
	 *
	 * Constructor of following functions
	 *
	 *   - login(user, password, ip)
	 *   - authenticate(token)
	 *   - getSecret()
	 *
	 * It will find or create a secret.key in `dataLocation`, then setup the adminPassword for user login.
	 *
	 */
	
	module.exports = function (_ref) {
	  var dataLocation = _ref.dataLocation,
	      securityConfig = _ref.securityConfig,
	      db = _ref.db;
	
	
	  var authentication = (0, _authentication2.default)({ dataLocation: dataLocation, securityConfig: securityConfig, db: db });
	  var tokenExpiry = securityConfig.tokenExpiry;
	
	  // login function that returns a {success, reason, token} object
	  // accounts for number of bad attempts
	
	  var login = function () {
	    var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee(user, password) {
	      var ip = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'all';
	      var canAttempt, loginUser, secret;
	      return regeneratorRuntime.wrap(function _callee$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              _context.next = 2;
	              return authentication.attempt(ip);
	
	            case 2:
	              canAttempt = _context.sent;
	
	              if (canAttempt) {
	                _context.next = 5;
	                break;
	              }
	
	              return _context.abrupt('return', { success: false, reason: 'Too many login attempts. Try again later.' });
	
	            case 5:
	              _context.next = 7;
	              return authentication.authenticate(user, password, ip);
	
	            case 7:
	              loginUser = _context.sent;
	
	              if (!loginUser) {
	                _context.next = 15;
	                break;
	              }
	
	              _context.next = 11;
	              return authentication.getSecret();
	
	            case 11:
	              secret = _context.sent;
	              return _context.abrupt('return', {
	                success: true,
	                token: _jsonwebtoken2.default.sign({ user: loginUser }, secret, { expiresIn: tokenExpiry })
	              });
	
	            case 15:
	              return _context.abrupt('return', {
	                success: false,
	                reason: 'Bad username / password'
	              });
	
	            case 16:
	            case 'end':
	              return _context.stop();
	          }
	        }
	      }, _callee, this);
	    }));
	
	    return function login(_x, _x2) {
	      return _ref2.apply(this, arguments);
	    };
	  }();
	
	  /**
	   * @param {string} token
	   * @return {boolean} whether the token is valid
	   */
	  var authenticate = function () {
	    var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(token) {
	      var secret, decoded, verified;
	      return regeneratorRuntime.wrap(function _callee2$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              _context2.prev = 0;
	              _context2.next = 3;
	              return authentication.getSecret();
	
	            case 3:
	              secret = _context2.sent;
	              decoded = _jsonwebtoken2.default.verify(token, secret);
	
	              if (!authentication.verifyUser) {
	                _context2.next = 11;
	                break;
	              }
	
	              _context2.next = 8;
	              return authentication.verifyUser(decoded);
	
	            case 8:
	              _context2.t0 = _context2.sent;
	              _context2.next = 12;
	              break;
	
	            case 11:
	              _context2.t0 = true;
	
	            case 12:
	              verified = _context2.t0;
	              return _context2.abrupt('return', verified && decoded.user);
	
	            case 16:
	              _context2.prev = 16;
	              _context2.t1 = _context2['catch'](0);
	              return _context2.abrupt('return', false);
	
	            case 19:
	            case 'end':
	              return _context2.stop();
	          }
	        }
	      }, _callee2, this, [[0, 16]]);
	    }));
	
	    return function authenticate(_x4) {
	      return _ref3.apply(this, arguments);
	    };
	  }();
	
	  return {
	    login: login,
	    authenticate: authenticate,
	    getSecret: authentication.getSecret,
	    _authentication: authentication
	  };
	};

/***/ },
/* 52 */
/***/ function(module, exports) {

	module.exports = require("jsonwebtoken");

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _fs = __webpack_require__(13);
	
	var _fs2 = _interopRequireDefault(_fs);
	
	var _path = __webpack_require__(3);
	
	var _path2 = _interopRequireDefault(_path);
	
	var _crypto = __webpack_require__(18);
	
	var _crypto2 = _interopRequireDefault(_crypto);
	
	var _bluebird = __webpack_require__(25);
	
	var _bluebird2 = _interopRequireDefault(_bluebird);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = function (_ref) {
	  var dataLocation = _ref.dataLocation,
	      securityConfig = _ref.securityConfig;
	
	
	  // reading secret from data or creating new secret
	  var secret = '';
	  var secretPath = _path2.default.join(dataLocation, 'secret.key');
	
	  var createNewSecret = function createNewSecret() {
	    secret = _crypto2.default.randomBytes(256).toString();
	    _fs2.default.writeFileSync(secretPath, secret);
	    return secret;
	  };
	
	  if (_fs2.default.existsSync(secretPath)) {
	    secret = _fs2.default.readFileSync(secretPath);
	  }
	
	  if (!secret || secret.length < 15) {
	    secret = createNewSecret();
	  }
	
	  var adminPassword = process.env.BOTPRESS_ADMIN_PASSWORD || securityConfig.password;
	
	  // a per-ip cache that logs login attempts
	  var attempts = {};
	  var lastCleanTimestamp = new Date();
	  var maxAttempts = securityConfig.maxAttempts,
	      resetAfter = securityConfig.resetAfter;
	
	
	  function attempt(ip) {
	    // reset the cache if time elapsed
	    if (new Date() - lastCleanTimestamp >= resetAfter) {
	      attempts = {};
	      lastCleanTimestamp = new Date();
	    }
	
	    return (attempts[ip] || 0) < maxAttempts;
	  }
	
	  function authenticate(user, password, ip) {
	    if (typeof user === 'string' && user.toLowerCase() === 'admin' && typeof password === 'string' && password === adminPassword) {
	      attempts[ip] = 0;
	      return {
	        id: 0,
	        email: 'admin@botpress.io',
	        first_name: 'Admin',
	        last_name: 'Admin',
	        avatar_url: null,
	        roles: ['admin']
	      };
	    } else {
	      attempts[ip] = (attempts[ip] || 0) + 1;
	      return null;
	    }
	  }
	
	  function getSecret() {
	    return secret;
	  }
	
	  function resetSecret() {
	    return createNewSecret();
	  }
	
	  // Public API
	  return {
	    attempt: _bluebird2.default.method(attempt),
	    authenticate: _bluebird2.default.method(authenticate),
	    getSecret: _bluebird2.default.method(getSecret),
	    resetSecret: _bluebird2.default.method(resetSecret)
	  };
	};

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _lodash = __webpack_require__(12);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _fs = __webpack_require__(13);
	
	var _fs2 = _interopRequireDefault(_fs);
	
	var _path = __webpack_require__(3);
	
	var _path2 = _interopRequireDefault(_path);
	
	var _uuid = __webpack_require__(55);
	
	var _uuid2 = _interopRequireDefault(_uuid);
	
	var _util = __webpack_require__(14);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// TODO this can be an util
	var createJsonStore = function createJsonStore(filePath, initData) {
	  return {
	    load: function load() {
	      if (_fs2.default.existsSync(filePath)) {
	        return JSON.parse(_fs2.default.readFileSync(filePath));
	      }
	
	      return initData;
	    },
	
	    save: function save(data) {
	      _fs2.default.writeFileSync(filePath, JSON.stringify(data));
	    }
	  };
	};
	
	var bindEvents = function bindEvents(loadNotifs, saveNotifs, events) {
	  events.on('notifications.getAll', function () {
	    events.emit('notifications.all', loadNotifs());
	  });
	
	  var markReadIf = function markReadIf(cond) {
	    var notifications = loadNotifs().map(function (notif) {
	      if (cond(notif)) {
	        notif.read = true;
	      }
	      return notif;
	    });
	
	    saveNotifs(notifications);
	    events.emit('notifications.all', notifications);
	  };
	
	  events.on('notifications.read', function (id) {
	    markReadIf(function (notif) {
	      return notif.id === id;
	    });
	  });
	
	  events.on('notifications.allRead', function () {
	    markReadIf(function () {
	      return true;
	    });
	  });
	
	  events.on('notifications.trashAll', function () {
	    saveNotifs([]);
	    events.emit('notifications.all', []);
	  });
	};
	
	exports.default = function (dataLocation, notifConfig, modules, events, logger) {
	  var notificationsFile = _path2.default.join(dataLocation, notifConfig.file);
	
	  var _createJsonStore = createJsonStore(notificationsFile, []),
	      loadNotifs = _createJsonStore.load,
	      saveNotifs = _createJsonStore.save;
	
	  bindEvents(loadNotifs, saveNotifs, events);
	
	  var sendNotif = function sendNotif(_ref) {
	    var message = _ref.message,
	        url = _ref.url,
	        level = _ref.level,
	        sound = _ref.sound;
	
	
	    if (!message || typeof message !== 'string') {
	      throw new Error('\'message\' is mandatory and should be a string');
	    }
	
	    if (!level || typeof level !== 'string' || !_lodash2.default.includes(['info', 'error', 'success'], level.toLowerCase())) {
	      level = 'info';
	    } else {
	      level = level.toLowerCase();
	    }
	
	    var callingFile = getOriginatingModule();
	    var callingModuleRoot = callingFile && (0, _util.resolveModuleRootPath)(callingFile);
	
	    var module = _lodash2.default.find(modules, function (mod) {
	      return mod.root === callingModuleRoot;
	    });
	
	    var options = {
	      // TODO should probably go in settings as defaults
	      moduleId: 'botpress',
	      icon: 'view_module',
	      name: 'botpress',
	      url: url || '/'
	    };
	
	    if (module) {
	      // because the bot itself can send notifications
	      options = {
	        moduleId: module.name,
	        icon: module.settings.menuIcon,
	        name: module.settings.menuText,
	        url: url
	      };
	
	      if (!url || typeof url !== 'string') {
	        options.url = '/modules/' + module.name;
	      }
	    }
	
	    var notification = {
	      id: _uuid2.default.v4(),
	      message: message,
	      level: level,
	      moduleId: options.moduleId,
	      icon: options.icon,
	      name: options.name,
	      url: options.url,
	      date: new Date(),
	      sound: sound || false,
	      read: false
	    };
	
	    var notifications = loadNotifs();
	    if (notifications.length >= notifConfig.maxLength) {
	      notifications.pop();
	    }
	
	    notifications.unshift(notification);
	    saveNotifs(notifications);
	
	    events.emit('notifications.new', notification);
	
	    var logMessage = '[notification::' + notification.moduleId + '] ' + notification.message;
	    if (logger) {
	      (logger[level] || logger.info)(logMessage);
	    }
	  };
	
	  return {
	    load: loadNotifs,
	    save: saveNotifs,
	    send: sendNotif
	  };
	};
	
	function getOriginatingModule() {
	  // TODO Explain hack
	  var origPrepareStackTrace = Error.prepareStackTrace;
	  Error.prepareStackTrace = function (_, stack) {
	    return stack;
	  };
	  var err = new Error();
	  var stack = err.stack;
	  Error.prepareStackTrace = origPrepareStackTrace;
	  stack.shift();
	
	  return stack[1].getFileName();
	}

/***/ },
/* 55 */
/***/ function(module, exports) {

	module.exports = require("uuid");

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _mware = __webpack_require__(45);
	
	var _mware2 = _interopRequireDefault(_mware);
	
	var _listeners = __webpack_require__(47);
	
	var _listeners2 = _interopRequireDefault(_listeners);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = function () {
	
	  var chain = (0, _mware2.default)();
	  var handler = function handler(event, next) {
	    chain.run(event, function () {
	      next.apply(this, arguments);
	    });
	  };
	
	  var middleware = {
	    name: 'hear',
	    type: 'incoming',
	    order: 20,
	    module: 'botpress',
	    description: 'The built-in hear convenience middleware',
	    handler: handler
	  };
	
	  var hear = function hear(condition, callback) {
	    chain(_listeners2.default.hear(condition, callback));
	  };
	
	  return { hear: hear, middleware: middleware };
	};

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _lodash = __webpack_require__(12);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _listeners = __webpack_require__(47);
	
	var _listeners2 = _interopRequireDefault(_listeners);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = function (bp) {
	
	  var middleware = {
	    name: 'fallback',
	    type: 'incoming',
	    order: 200,
	    module: 'botpress',
	    description: 'The built-in fallback handler. You may override this by implementing bp.fallbackHandler',
	    handler: function handler(event, next) {
	      if (_lodash2.default.isFunction(bp.fallbackHandler)) {
	        bp.fallbackHandler(event, next);
	      }
	    }
	  };
	
	  return { middleware: middleware };
	};

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _bluebird = __webpack_require__(25);
	
	var _bluebird2 = _interopRequireDefault(_bluebird);
	
	var _moment = __webpack_require__(5);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _tables = __webpack_require__(59);
	
	var _tables2 = _interopRequireDefault(_tables);
	
	var _kvs2 = __webpack_require__(34);
	
	var _kvs3 = _interopRequireDefault(_kvs2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _bluebird2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _bluebird2.default.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	var initializeCoreDatabase = function initializeCoreDatabase(knex) {
	  if (!knex) {
	    throw new Error('You must initialize the database before');
	  }
	
	  return _bluebird2.default.mapSeries(_tables2.default, function (fn) {
	    return fn(knex);
	  });
	};
	
	var createKnex = function () {
	  var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(_ref2) {
	    var sqlite = _ref2.sqlite,
	        postgres = _ref2.postgres;
	
	    var _knex;
	
	    return regeneratorRuntime.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            _knex = null;
	
	
	            if (postgres.enabled) {
	
	              // If we're passing in a postgres connection string, 
	              // use that instead of the other params
	              if (postgres.connection) {
	                _knex = __webpack_require__(33)({
	                  client: 'pg',
	                  connection: postgres.connection,
	                  useNullAsDefault: true
	                });
	              } else {
	                _knex = __webpack_require__(33)({
	                  client: 'pg',
	                  connection: {
	                    host: postgres.host,
	                    port: postgres.port,
	                    user: postgres.user,
	                    password: postgres.password,
	                    database: postgres.database,
	                    ssl: postgres.ssl
	                  },
	                  useNullAsDefault: true
	                });
	              }
	            } else {
	              _knex = __webpack_require__(33)({
	                client: 'sqlite3',
	                connection: { filename: sqlite.location },
	                useNullAsDefault: true,
	                pool: {
	                  afterCreate: function afterCreate(conn, cb) {
	                    conn.run('PRAGMA foreign_keys = ON', cb);
	                  }
	                }
	              });
	            }
	
	            _context.next = 4;
	            return initializeCoreDatabase(_knex);
	
	          case 4:
	            return _context.abrupt('return', _knex);
	
	          case 5:
	          case 'end':
	            return _context.stop();
	        }
	      }
	    }, _callee, undefined);
	  }));
	
	  return function createKnex(_x) {
	    return _ref.apply(this, arguments);
	  };
	}();
	
	module.exports = function (_ref3) {
	  var sqlite = _ref3.sqlite,
	      postgres = _ref3.postgres;
	
	
	  var knex = null;
	
	  var getDb = function () {
	    var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {
	      return regeneratorRuntime.wrap(function _callee2$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              if (!knex) {
	                knex = createKnex({ sqlite: sqlite, postgres: postgres });
	              }
	
	              _context2.next = 3;
	              return knex;
	
	            case 3:
	              return _context2.abrupt('return', _context2.sent);
	
	            case 4:
	            case 'end':
	              return _context2.stop();
	          }
	        }
	      }, _callee2, undefined);
	    }));
	
	    return function getDb() {
	      return _ref4.apply(this, arguments);
	    };
	  }();
	
	  var saveUser = function saveUser(_ref5) {
	    var id = _ref5.id,
	        platform = _ref5.platform,
	        gender = _ref5.gender,
	        timezone = _ref5.timezone,
	        locale = _ref5.locale,
	        picture_url = _ref5.picture_url,
	        first_name = _ref5.first_name,
	        last_name = _ref5.last_name;
	
	    var userId = platform + ':' + id;
	    var userRow = {
	      id: userId,
	      userId: id,
	      platform: platform,
	      gender: gender || 'unknown',
	      timezone: timezone || null,
	      locale: locale || null,
	      created_on: (0, _moment2.default)(new Date()).toISOString(),
	      picture_url: picture_url,
	      last_name: last_name,
	      first_name: first_name
	    };
	
	    return getDb().then(function (knex) {
	      var query = knex('users').insert(userRow).where(function () {
	        return this.select(knex.raw(1)).from('users').where('id', '=', userId);
	      });
	
	      if (postgres.enabled) {
	        query = query + ' on conflict (id) do nothing';
	      } else {
	        // SQLite
	        query = query.toString().replace(/^insert/i, 'insert or ignore');
	      }
	
	      return knex.raw(query);
	    });
	  };
	
	  var kvs_instance = null;
	
	  var createKvs = function () {
	    var _ref6 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {
	      var knex, _kvs;
	
	      return regeneratorRuntime.wrap(function _callee3$(_context3) {
	        while (1) {
	          switch (_context3.prev = _context3.next) {
	            case 0:
	              _context3.next = 2;
	              return getDb();
	
	            case 2:
	              knex = _context3.sent;
	              _kvs = new _kvs3.default(knex);
	              _context3.next = 6;
	              return _kvs.bootstrap();
	
	            case 6:
	              return _context3.abrupt('return', _kvs);
	
	            case 7:
	            case 'end':
	              return _context3.stop();
	          }
	        }
	      }, _callee3, undefined);
	    }));
	
	    return function createKvs() {
	      return _ref6.apply(this, arguments);
	    };
	  }();
	
	  var getKvs = function () {
	    var _ref7 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {
	      return regeneratorRuntime.wrap(function _callee4$(_context4) {
	        while (1) {
	          switch (_context4.prev = _context4.next) {
	            case 0:
	              if (!kvs_instance) {
	                kvs_instance = createKvs();
	              }
	
	              _context4.next = 3;
	              return kvs_instance;
	
	            case 3:
	              return _context4.abrupt('return', _context4.sent);
	
	            case 4:
	            case 'end':
	              return _context4.stop();
	          }
	        }
	      }, _callee4, undefined);
	    }));
	
	    return function getKvs() {
	      return _ref7.apply(this, arguments);
	    };
	  }();
	
	  var kvsGet = function kvsGet() {
	    var args = arguments;
	    return getKvs().then(function (instance) {
	      return instance.get.apply(null, args);
	    });
	  };
	
	  var kvsSet = function kvsSet() {
	    var args = arguments;
	    return getKvs().then(function (instance) {
	      return instance.set.apply(null, args);
	    });
	  };
	
	  return {
	    get: getDb,
	    saveUser: saveUser,
	    location: postgres.enabled ? 'postgres' : sqlite.location,
	    kvs: { get: kvsGet, set: kvsSet }
	  };
	};

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _database = __webpack_require__(60);
	
	module.exports = [__webpack_require__(61), __webpack_require__(62)].concat(_database.table_factories);

/***/ },
/* 60 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = {
	  table_factories: []
	};

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _helpers = __webpack_require__(4);
	
	var _helpers2 = _interopRequireDefault(_helpers);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = function (knex) {
	  return (0, _helpers2.default)(knex).createTableIfNotExists('users', function (table) {
	    table.string('id').primary();
	    table.string('userId');
	    table.string('platform');
	    table.enu('gender', ['unknown', 'male', 'female']);
	    table.integer('timezone');
	    table.string('picture_url');
	    table.string('first_name');
	    table.string('last_name');
	    table.string('locale');
	    table.timestamp('created_on');
	  });
	}; /*
	     A table storing all the interlocutors (users) and their information
	   */

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _helpers = __webpack_require__(4);
	
	var _helpers2 = _interopRequireDefault(_helpers);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = function (knex) {
	  return (0, _helpers2.default)(knex).createTableIfNotExists('users_tags', function (table) {
	    table.string('userId');
	    table.string('tag');
	    table.string('value');
	    table.timestamp('tagged_on');
	    table.unique(['userId', 'tag']);
	  });
	}; /*
	     A table storing all the user tags
	   */

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _fs = __webpack_require__(13);
	
	var _fs2 = _interopRequireDefault(_fs);
	
	var _util = __webpack_require__(14);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = function (projectLocation) {
	
	  var getBotInformation = function getBotInformation() {
	    var packageJsonPath = (0, _util.resolveProjectFile)('package.json', projectLocation, true);
	    var packageJson = JSON.parse(_fs2.default.readFileSync(packageJsonPath));
	
	    return {
	      name: packageJson.name,
	      version: packageJson.version,
	      description: packageJson.description || '<no description>',
	      author: packageJson.author || '<no author>',
	      license: packageJson.license || 'AGPL-v3.0'
	    };
	  };
	
	  return { getBotInformation: getBotInformation };
	};

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _path = __webpack_require__(3);
	
	var _path2 = _interopRequireDefault(_path);
	
	var _util = __webpack_require__(65);
	
	var _util2 = _interopRequireDefault(_util);
	
	var _lodash = __webpack_require__(12);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _bluebird = __webpack_require__(25);
	
	var _bluebird2 = _interopRequireDefault(_bluebird);
	
	var _engine = __webpack_require__(66);
	
	var _engine2 = _interopRequireDefault(_engine);
	
	var _proactive = __webpack_require__(69);
	
	var _proactive2 = _interopRequireDefault(_proactive);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _bluebird2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _bluebird2.default.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	var fs = _bluebird2.default.promisifyAll(__webpack_require__(13));
	
	module.exports = function (_ref) {
	  var getDocument = function () {
	    var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {
	      var _this = this;
	
	      var stats, _ret;
	
	      return regeneratorRuntime.wrap(function _callee2$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              _context2.next = 2;
	              return fs.statAsync(storagePath);
	
	            case 2:
	              stats = _context2.sent;
	
	              if (!stats.isDirectory()) {
	                _context2.next = 8;
	                break;
	              }
	
	              return _context2.delegateYield(regeneratorRuntime.mark(function _callee() {
	                var files, contents;
	                return regeneratorRuntime.wrap(function _callee$(_context) {
	                  while (1) {
	                    switch (_context.prev = _context.next) {
	                      case 0:
	                        _context.next = 2;
	                        return fs.readdirAsync(storagePath);
	
	                      case 2:
	                        files = _context.sent;
	                        contents = {};
	
	
	                        files.forEach(function (file) {
	                          var filename = _path2.default.basename(file, _path2.default.extname(file));
	                          contents[filename] = fs.readFileAsync(_path2.default.join(storagePath, file), 'utf8');
	                        });
	
	                        return _context.abrupt('return', {
	                          v: _bluebird2.default.props(contents)
	                        });
	
	                      case 6:
	                      case 'end':
	                        return _context.stop();
	                    }
	                  }
	                }, _callee, _this);
	              })(), 't0', 5);
	
	            case 5:
	              _ret = _context2.t0;
	
	              if (!((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object")) {
	                _context2.next = 8;
	                break;
	              }
	
	              return _context2.abrupt('return', _ret.v);
	
	            case 8:
	              return _context2.abrupt('return', fs.readFileAsync(storagePath, 'utf8'));
	
	            case 9:
	            case 'end':
	              return _context2.stop();
	          }
	        }
	      }, _callee2, this);
	    }));
	
	    return function getDocument() {
	      return _ref4.apply(this, arguments);
	    };
	  }();
	
	  var sendBloc = function () {
	    var _ref5 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(incomingEvent, blocName) {
	      var additionalData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	      var split, fileName, markdown, fullContext, blocs, bloc;
	      return regeneratorRuntime.wrap(function _callee3$(_context3) {
	        while (1) {
	          switch (_context3.prev = _context3.next) {
	            case 0:
	              blocName = blocName[0] === '#' ? blocName.substr(1) : blocName;
	              split = blocName.split('.');
	              fileName = null;
	
	
	              if (split.length === 2) {
	                fileName = split[0];
	                blocName = split[1];
	              }
	
	              _context3.next = 6;
	              return getDocument();
	
	            case 6:
	              markdown = _context3.sent;
	
	
	              // TODO Add more context
	              fullContext = Object.assign({
	                user: incomingEvent.user,
	                originalEvent: incomingEvent
	              }, additionalData);
	
	              if (!_lodash2.default.isObject(markdown)) {
	                _context3.next = 14;
	                break;
	              }
	
	              if (fileName) {
	                _context3.next = 11;
	                break;
	              }
	
	              throw new Error('Unknown UMM bloc filename: ' + blocName);
	
	            case 11:
	              if (markdown[fileName]) {
	                _context3.next = 13;
	                break;
	              }
	
	              throw new Error('UMM content ' + fileName + '.yml not found');
	
	            case 13:
	
	              markdown = markdown[fileName];
	
	            case 14:
	              blocs = parse({
	                context: fullContext,
	                outputPlatform: incomingEvent.platform,
	                markdown: markdown,
	                incomingEvent: incomingEvent
	              });
	
	              // TODO check if message OK and catch errors
	              // TODO throw if bloc does not exist
	
	              bloc = blocs[blocName];
	              return _context3.abrupt('return', doSendBloc(bloc));
	
	            case 17:
	            case 'end':
	              return _context3.stop();
	          }
	        }
	      }, _callee3, this);
	    }));
	
	    return function sendBloc(_x, _x2) {
	      return _ref5.apply(this, arguments);
	    };
	  }();
	
	  var logger = _ref.logger,
	      middlewares = _ref.middlewares,
	      botfile = _ref.botfile,
	      projectLocation = _ref.projectLocation,
	      db = _ref.db;
	
	
	  var processors = {}; // A map of all the platforms that can process outgoing messages
	  var templates = {}; // A map of all the platforms templates
	  var storagePath = getStoragePath();
	
	  function registerConnector(_ref2) {
	    var platform = _ref2.platform,
	        processOutgoing = _ref2.processOutgoing,
	        templates = _ref2.templates;
	
	
	    // TODO throw if templates not array
	    // TODO throw if platform not string
	    // TODO throw if processOutgoing not a function
	    // TODO throw if platform already registered
	
	    logger.verbose('[UMM] Enabled for ' + platform); // TODO remove that
	
	    processors[platform] = processOutgoing;
	    templates[platform] = templates;
	  }
	
	  function parse(_ref3) {
	    var context = _ref3.context,
	        outputPlatform = _ref3.outputPlatform,
	        _ref3$markdown = _ref3.markdown,
	        markdown = _ref3$markdown === undefined ? null : _ref3$markdown,
	        _ref3$incomingEvent = _ref3.incomingEvent,
	        incomingEvent = _ref3$incomingEvent === undefined ? null : _ref3$incomingEvent;
	
	    // TODO throw if context empty
	
	    // TODO throw if markdown nil <<<==== Pick default markdown
	    // TODO throw if incomingEvents null <<<==== MOCK IT
	
	    var options = {
	      throwIfNoPlatform: true,
	      currentPlatform: outputPlatform
	    };
	
	    return (0, _engine2.default)({ markdown: markdown, context: context, options: options, processors: processors, incomingEvent: incomingEvent });
	  }
	
	  function getTemplates() {
	    return _lodash2.default.merge({}, templates); // Return a deep copy
	  }
	
	  function getStoragePath() {
	    var resolve = function resolve(file) {
	      return _path2.default.resolve(projectLocation, file);
	    };
	    var ummPath = _lodash2.default.get(botfile, 'umm.contentPath');
	
	    if (!ummPath) {
	      var single = resolve('content.yml');
	      var folder = resolve('content');
	
	      if (fs.existsSync(single)) {
	        ummPath = single;
	      } else if (fs.existsSync(folder)) {
	        ummPath = folder;
	      } else {
	        throw new Error('UMM content location not found');
	      }
	    }
	
	    if (_path2.default.isAbsolute(ummPath)) {
	      return ummPath;
	    } else {
	      return _path2.default.resolve(projectLocation, ummPath);
	    }
	  }
	
	  function saveDocument(content) {
	    if (_lodash2.default.isObject(content)) {
	      return _bluebird2.default.map(Object.keys(content), function (fileName) {
	        var filePath = _path2.default.join(storagePath, fileName + '.yml');
	        return fs.writeFileAsync(filePath, content[fileName], 'utf8');
	      });
	    }
	
	    return fs.writeFileAsync(storagePath, content, 'utf8');
	  }
	
	  function doSendBloc(bloc) {
	    return _bluebird2.default.mapSeries(bloc, function (message) {
	      if (message.__internal) {
	        if (message.type === 'wait') {
	          return _bluebird2.default.delay(message.wait);
	        }
	      } else {
	        return middlewares.sendOutgoing(message);
	      }
	    });
	  }
	
	  function processIncoming(event, next) {
	    event.reply = function (blocName) {
	      var additionalData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	      return sendBloc(event, blocName, additionalData);
	    };
	
	    next();
	  }
	
	  var incomingMiddleware = {
	    name: 'UMM.instrumentation',
	    type: 'incoming',
	    order: 2, // Should really be first
	    module: 'botpress',
	    description: 'Built-in Botpress middleware that adds a `.reply` to events. Works with UMM.',
	    handler: processIncoming
	  };
	
	  var proactiveMethods = (0, _proactive2.default)({ sendBloc: sendBloc, db: db });
	
	  return _extends({ registerConnector: registerConnector, parse: parse, getTemplates: getTemplates, incomingMiddleware: incomingMiddleware, getDocument: getDocument, saveDocument: saveDocument }, proactiveMethods);
	};

/***/ },
/* 65 */
/***/ function(module, exports) {

	module.exports = require("util");

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _mustache = __webpack_require__(67);
	
	var _mustache2 = _interopRequireDefault(_mustache);
	
	var _jsYaml = __webpack_require__(28);
	
	var _jsYaml2 = _interopRequireDefault(_jsYaml);
	
	var _ms = __webpack_require__(68);
	
	var _ms2 = _interopRequireDefault(_ms);
	
	var _lodash = __webpack_require__(12);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ParsingError = function (_Error) {
	  _inherits(ParsingError, _Error);
	
	  function ParsingError(bloc, instructionIndex, error) {
	    _classCallCheck(this, ParsingError);
	
	    var _this = _possibleConstructorReturn(this, (ParsingError.__proto__ || Object.getPrototypeOf(ParsingError)).call(this, 'Error parsing bloc \'' + bloc + '\' at instruction ' + (instructionIndex + 1) + ': ' + error));
	
	    _this.bloc = bloc;
	    _this.instructionIndex = instructionIndex;
	    _this.internalMessage = error;
	    Error.captureStackTrace(_this, ParsingError);
	    return _this;
	  }
	
	  return ParsingError;
	}(Error);
	
	var mapBlocs = function mapBlocs(rawBlocs, options, processors, incomingEvent) {
	  var currentPlatform = options.currentPlatform,
	      _options$throwIfNoPla = options.throwIfNoPlatform,
	      throwIfNoPlatform = _options$throwIfNoPla === undefined ? false : _options$throwIfNoPla;
	
	
	  if (!currentPlatform && throwIfNoPlatform) {
	    throw new Error('You need to supply `currentplatform`');
	  }
	
	  return _lodash2.default.mapValues(rawBlocs, mapBloc);
	
	  function premapInstruction(_ref) {
	    var instruction = _ref.instruction,
	        index = _ref.index,
	        instructions = _ref.instructions,
	        detectedPlatforms = _ref.detectedPlatforms,
	        bloc = _ref.bloc;
	
	
	    if (typeof instruction === 'string' || _lodash2.default.isArray(instruction)) {
	      return [{
	        text: instruction
	      }];
	    }
	
	    // Parsing conditionals
	    var evaluate = function evaluate(val, exp) {
	
	      if (typeof exp === 'boolean') {
	        return val === exp;
	      }if (_lodash2.default.isArrayLike(exp)) {
	        return val ? !_lodash2.default.isEmpty(exp) : _lodash2.default.isEmpty(exp);
	      } else {
	        return val ? !!exp : !exp;
	      }
	    };
	
	    if (!_lodash2.default.isNil(instruction.if) && !_lodash2.default.isNil(instruction.unless)) {
	      throw new ParsingError(bloc, index, "Message can't be both 'if' and 'else'.");
	    }
	
	    if (!_lodash2.default.isNil(instruction.unless) && !evaluate(false, instruction.unless)) {
	      return [];
	    }
	
	    if (!_lodash2.default.isNil(instruction.if) && !evaluate(true, instruction.if)) {
	      return [];
	    }
	
	    // Parsing ".on"
	    var i = Object.assign({}, instruction);
	    if (instruction.on) {
	      if (typeof instruction.on === 'string') {
	        var platforms = instruction.on.toLowerCase().split('+').map(_lodash2.default.trim);
	        if (!_lodash2.default.includes(platforms, currentPlatform.toLowerCase())) {
	          return [];
	        } else {
	          i['__platformSpecific'] = true;
	        }
	      } else if (_lodash2.default.isPlainObject(instruction.on)) {
	        (function () {
	          var on = _lodash2.default.mapKeys(instruction.on, function (__, key) {
	            return key.toLowerCase();
	          });
	
	          // This allows multiple platforms to be specified
	          // e.g. "messenger+slack+web"
	          _lodash2.default.keys(on).forEach(function (key) {
	            if (key.indexOf('+') >= 0) {
	              _lodash2.default.split(key, '+').forEach(function (alias) {
	                var trimmed = _lodash2.default.trim(alias);
	                on[trimmed] = _lodash2.default.merge({}, on[trimmed] || {}, on[key]);
	              });
	            }
	          });
	
	          i = Object.assign(i, on[currentPlatform.toLowerCase()], { on: currentPlatform });
	        })();
	      } else {
	        throw new ParsingError(bloc, index, '"on" must be a string or a plain object but was a ' + _typeof(instruction.on));
	      }
	    }
	
	    return [i];
	  }
	
	  function mapInstruction(_ref2) {
	    var instruction = _ref2.instruction,
	        messages = _ref2.messages,
	        bloc = _ref2.bloc;
	
	    var ret = [];
	
	    if (!_lodash2.default.isNil(instruction.wait)) {
	      ret.push({
	        __internal: true,
	        type: 'wait',
	        wait: _lodash2.default.isString(instruction.wait) ? (0, _ms2.default)(instruction.wait || 1000) : parseInt(instruction.wait) || 1000
	      });
	    }
	
	    if (!_lodash2.default.isNil(instruction.typing)) {
	      instruction.typing = _lodash2.default.isString(instruction.typing) ? (0, _ms2.default)(instruction.typing || 1000) : parseInt(instruction.typing) || 1000;
	    }
	
	    var raw = _lodash2.default.omit(instruction, ['unless', 'if', 'on', 'wait']);
	
	    if (!_lodash2.default.keys(raw).length) {
	      return ret;
	    }
	
	    if (_lodash2.default.isArray(instruction.text)) {
	      instruction.text = _lodash2.default.sample(instruction.text);
	    }
	
	    var processor = currentPlatform && processors[currentPlatform];
	    if (processor) {
	      var msg = processor({ instruction: instruction, messages: messages, blocName: bloc, event: incomingEvent });
	      if (msg) {
	        ret.push(msg);
	      }
	
	      return ret;
	    }
	
	    throw new Error('Unsupported platform: ' + currentPlatform);
	  }
	
	  function mapBloc(bloc, name) {
	    // if the bloc isn't an array, error
	
	    var messages = [];
	    var detectedPlatforms = [];
	    var instructions = [];
	
	    // Premapping allows for modifications, drop and addition of instructions
	    _lodash2.default.forEach(bloc, function (instruction, index) {
	      var add = premapInstruction({
	        instruction: instruction,
	        index: index,
	        instructions: bloc,
	        detectedPlatforms: detectedPlatforms,
	        bloc: name
	      });
	
	      add && _lodash2.default.forEach(add, function (i) {
	        return instructions.push(i);
	      });
	    });
	
	    _lodash2.default.forEach(instructions, function (instruction) {
	      var m = mapInstruction({ instruction: instruction, messages: messages, bloc: name });
	
	      if (!_lodash2.default.isNil(m)) {
	        // Messages can be null when the instruction only modified existing messages
	        m.forEach(function (message) {
	          return messages.push(message);
	        });
	      }
	    });
	
	    return messages;
	  }
	}; // mapBlocs
	
	module.exports = function (_ref3) {
	  var markdown = _ref3.markdown,
	      context = _ref3.context,
	      options = _ref3.options,
	      processors = _ref3.processors,
	      incomingEvent = _ref3.incomingEvent;
	
	  _mustache2.default.parse(markdown);
	  var mustached = _mustache2.default.render(markdown, context);
	
	  // The reason we support multi-doc is that people might want to separate documents
	  // Both visually and practically when the file gets large
	  var rawBlocs = {};
	  _jsYaml2.default.safeLoadAll(mustached, function (rawBloc) {
	    return Object.assign(rawBlocs, rawBloc);
	  });
	
	  return mapBlocs(rawBlocs, options, processors, incomingEvent);
	};

/***/ },
/* 67 */
/***/ function(module, exports) {

	module.exports = require("mustache");

/***/ },
/* 68 */
/***/ function(module, exports) {

	module.exports = require("ms");

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _util = __webpack_require__(65);
	
	var _util2 = _interopRequireDefault(_util);
	
	var _lodash = __webpack_require__(12);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _bluebird = __webpack_require__(25);
	
	var _bluebird2 = _interopRequireDefault(_bluebird);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _bluebird2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _bluebird2.default.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	module.exports = function (_ref) {
	  var getUser = function () {
	    var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee(id) {
	      var knex, users;
	      return regeneratorRuntime.wrap(function _callee$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              _context.next = 2;
	              return db.get();
	
	            case 2:
	              knex = _context.sent;
	              _context.next = 5;
	              return knex('users').where(function () {
	                if (id.indexOf(':') > 0) {
	                  this.where({ id: id });
	                } else {
	                  this.where('userId', id);
	                }
	              }).limit(1).select('*');
	
	            case 5:
	              users = _context.sent;
	
	              if (!(!users || users.length <= 0)) {
	                _context.next = 8;
	                break;
	              }
	
	              throw new Error('User "' + id + '" not found in the database');
	
	            case 8:
	              return _context.abrupt('return', users[0]);
	
	            case 9:
	            case 'end':
	              return _context.stop();
	          }
	        }
	      }, _callee, this);
	    }));
	
	    return function getUser(_x) {
	      return _ref2.apply(this, arguments);
	    };
	  }();
	
	  /**
	   * Sends a proactive UMM message to a user
	   * @param  {string|object} user UserId or a full user object
	   * @param  {string} bloc The bloc name to send
	   * @param  {object} data Additional data to provide to the bloc
	   * @return {Promise}      A promise that the bloc is sent
	   */
	
	
	  var sendToUser = function () {
	    var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(user, bloc, data) {
	      var text, forgedEvent;
	      return regeneratorRuntime.wrap(function _callee2$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              if (_lodash2.default.isString(bloc)) {
	                _context2.next = 2;
	                break;
	              }
	
	              throw new Error('Invalid bloc id: ' + bloc);
	
	            case 2:
	              if (!_lodash2.default.isString(user)) {
	                _context2.next = 6;
	                break;
	              }
	
	              _context2.next = 5;
	              return getUser(user);
	
	            case 5:
	              user = _context2.sent;
	
	            case 6:
	              if (!(!user || !user.id)) {
	                _context2.next = 8;
	                break;
	              }
	
	              throw new Error('Invalid user object: ' + _util2.default.inspect(user));
	
	            case 8:
	              text = 'This is not a real event, it has been forged by UMM.';
	              forgedEvent = {
	                platform: user.platform,
	                user: user,
	                type: 'proactive',
	                text: text,
	                raw: { forged: true, message: text }
	              };
	              return _context2.abrupt('return', sendBloc(forgedEvent, bloc, data));
	
	            case 11:
	            case 'end':
	              return _context2.stop();
	          }
	        }
	      }, _callee2, this);
	    }));
	
	    return function sendToUser(_x2, _x3, _x4) {
	      return _ref3.apply(this, arguments);
	    };
	  }();
	
	  var sendBloc = _ref.sendBloc,
	      db = _ref.db;
	
	
	  return { sendToUser: sendToUser };
	};

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _lodash = __webpack_require__(12);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _helpers = __webpack_require__(4);
	
	var _helpers2 = _interopRequireDefault(_helpers);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	module.exports = function (_ref) {
	  var tag = function () {
	    var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee(userId, tag) {
	      var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	      var knex;
	      return regeneratorRuntime.wrap(function _callee$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              _context.next = 2;
	              return db.get();
	
	            case 2:
	              knex = _context.sent;
	
	
	              tag = _lodash2.default.toUpper(tag);
	
	              _context.next = 6;
	              return hasTag(userId, tag);
	
	            case 6:
	              if (!_context.sent) {
	                _context.next = 11;
	                break;
	              }
	
	              _context.next = 9;
	              return knex('users_tags').where({ userId: userId, tag: tag }).update({
	                userId: userId,
	                tag: tag,
	                value: value,
	                tagged_on: (0, _helpers2.default)(knex).date.now()
	              }).then();
	
	            case 9:
	              _context.next = 13;
	              break;
	
	            case 11:
	              _context.next = 13;
	              return knex('users_tags').insert({
	                userId: userId,
	                tag: tag,
	                value: value,
	                tagged_on: (0, _helpers2.default)(knex).date.now()
	              }).then();
	
	            case 13:
	              return _context.abrupt('return', true);
	
	            case 14:
	            case 'end':
	              return _context.stop();
	          }
	        }
	      }, _callee, this);
	    }));
	
	    return function tag(_x, _x2) {
	      return _ref2.apply(this, arguments);
	    };
	  }();
	
	  var untag = function () {
	    var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(userId, tag) {
	      var knex;
	      return regeneratorRuntime.wrap(function _callee2$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              _context2.next = 2;
	              return db.get();
	
	            case 2:
	              knex = _context2.sent;
	              return _context2.abrupt('return', knex('users_tags').where({ userId: userId, tag: _lodash2.default.toUpper(tag) }).del().then());
	
	            case 4:
	            case 'end':
	              return _context2.stop();
	          }
	        }
	      }, _callee2, this);
	    }));
	
	    return function untag(_x4, _x5) {
	      return _ref3.apply(this, arguments);
	    };
	  }();
	
	  var hasTag = function () {
	    var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(userId, tag) {
	      var knex;
	      return regeneratorRuntime.wrap(function _callee3$(_context3) {
	        while (1) {
	          switch (_context3.prev = _context3.next) {
	            case 0:
	              _context3.next = 2;
	              return db.get();
	
	            case 2:
	              knex = _context3.sent;
	              return _context3.abrupt('return', knex('users_tags').select('userId').where({ userId: userId, tag: _lodash2.default.toUpper(tag) }).limit(1).then(function (ret) {
	                return ret.length > 0;
	              }));
	
	            case 4:
	            case 'end':
	              return _context3.stop();
	          }
	        }
	      }, _callee3, this);
	    }));
	
	    return function hasTag(_x6, _x7) {
	      return _ref4.apply(this, arguments);
	    };
	  }();
	
	  var getTag = function () {
	    var _ref5 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4(userId, tag) {
	      var knex;
	      return regeneratorRuntime.wrap(function _callee4$(_context4) {
	        while (1) {
	          switch (_context4.prev = _context4.next) {
	            case 0:
	              _context4.next = 2;
	              return db.get();
	
	            case 2:
	              knex = _context4.sent;
	              return _context4.abrupt('return', knex('users_tags').select('value').where({ userId: userId, tag: _lodash2.default.toUpper(tag) }).limit(1).then().get(0).then(function (ret) {
	                return ret && ret.value;
	              }));
	
	            case 4:
	            case 'end':
	              return _context4.stop();
	          }
	        }
	      }, _callee4, this);
	    }));
	
	    return function getTag(_x8, _x9) {
	      return _ref5.apply(this, arguments);
	    };
	  }();
	
	  var getTags = function () {
	    var _ref6 = _asyncToGenerator(regeneratorRuntime.mark(function _callee5(userId) {
	      var knex;
	      return regeneratorRuntime.wrap(function _callee5$(_context5) {
	        while (1) {
	          switch (_context5.prev = _context5.next) {
	            case 0:
	              _context5.next = 2;
	              return db.get();
	
	            case 2:
	              knex = _context5.sent;
	              return _context5.abrupt('return', knex('users_tags').where({ userId: userId }).select('tag', 'value').then(function (tags) {
	                return _lodash2.default.map(tags, function (v) {
	                  return { tag: v.tag, value: v.value };
	                });
	              }));
	
	            case 4:
	            case 'end':
	              return _context5.stop();
	          }
	        }
	      }, _callee5, this);
	    }));
	
	    return function getTags(_x10) {
	      return _ref6.apply(this, arguments);
	    };
	  }();
	
	  var getCreationDate = function () {
	    var _ref7 = _asyncToGenerator(regeneratorRuntime.mark(function _callee6(userId) {
	      var knex;
	      return regeneratorRuntime.wrap(function _callee6$(_context6) {
	        while (1) {
	          switch (_context6.prev = _context6.next) {
	            case 0:
	              _context6.next = 2;
	              return db.get();
	
	            case 2:
	              knex = _context6.sent;
	              return _context6.abrupt('return', knex('users').where({ userId: userId }).select('created_on').limit(1).then().get(0).then(function (ret) {
	                return ret && ret.created_on;
	              }));
	
	            case 4:
	            case 'end':
	              return _context6.stop();
	          }
	        }
	      }, _callee6, this);
	    }));
	
	    return function getCreationDate(_x11) {
	      return _ref7.apply(this, arguments);
	    };
	  }();
	
	  var list = function () {
	    var _ref8 = _asyncToGenerator(regeneratorRuntime.mark(function _callee8() {
	      var _this = this;
	
	      var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;
	      var fromId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	      var knex, fromDate;
	      return regeneratorRuntime.wrap(function _callee8$(_context8) {
	        while (1) {
	          switch (_context8.prev = _context8.next) {
	            case 0:
	              _context8.next = 2;
	              return db.get();
	
	            case 2:
	              knex = _context8.sent;
	              fromDate = (0, _helpers2.default)(knex).date.now();
	
	              if (_lodash2.default.isNil(fromId)) {
	                _context8.next = 8;
	                break;
	              }
	
	              _context8.next = 7;
	              return getCreationDate(fromId);
	
	            case 7:
	              fromDate = _context8.sent;
	
	            case 8:
	              return _context8.abrupt('return', knex('users').select('userId', 'platform', 'gender', 'timezone', 'locale', 'picture_url', 'first_name', 'last_name', 'created_on').orderBy('created_on', 'desc').whereNot('userId', fromId).where('created_on', '<', fromDate).limit(limit).then(function (users) {
	                return Promise.all(_lodash2.default.map(users, function () {
	                  var _ref9 = _asyncToGenerator(regeneratorRuntime.mark(function _callee7(user) {
	                    var tags;
	                    return regeneratorRuntime.wrap(function _callee7$(_context7) {
	                      while (1) {
	                        switch (_context7.prev = _context7.next) {
	                          case 0:
	                            _context7.next = 2;
	                            return getTags(user.userId);
	
	                          case 2:
	                            tags = _context7.sent;
	
	                            user.id = user.userId;
	                            user.tags = tags;
	                            return _context7.abrupt('return', user);
	
	                          case 6:
	                          case 'end':
	                            return _context7.stop();
	                        }
	                      }
	                    }, _callee7, _this);
	                  }));
	
	                  return function (_x14) {
	                    return _ref9.apply(this, arguments);
	                  };
	                }()));
	              }));
	
	            case 9:
	            case 'end':
	              return _context8.stop();
	          }
	        }
	      }, _callee8, this);
	    }));
	
	    return function list() {
	      return _ref8.apply(this, arguments);
	    };
	  }();
	
	  var count = function () {
	    var _ref10 = _asyncToGenerator(regeneratorRuntime.mark(function _callee9() {
	      var knex;
	      return regeneratorRuntime.wrap(function _callee9$(_context9) {
	        while (1) {
	          switch (_context9.prev = _context9.next) {
	            case 0:
	              _context9.next = 2;
	              return db.get();
	
	            case 2:
	              knex = _context9.sent;
	              return _context9.abrupt('return', knex('users').count('* as count').get(0).then(function (ret) {
	                return ret;
	              }));
	
	            case 4:
	            case 'end':
	              return _context9.stop();
	          }
	        }
	      }, _callee9, this);
	    }));
	
	    return function count() {
	      return _ref10.apply(this, arguments);
	    };
	  }();
	
	  var db = _ref.db;
	
	
	  return { tag: tag, untag: untag, hasTag: hasTag, getTag: getTag, getTags: getTags, list: list, count: count };
	};

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _eventemitter = __webpack_require__(43);
	
	var _eventemitter2 = _interopRequireDefault(_eventemitter);
	
	var _ms = __webpack_require__(68);
	
	var _ms2 = _interopRequireDefault(_ms);
	
	var _lodash = __webpack_require__(12);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _bluebird = __webpack_require__(25);
	
	var _bluebird2 = _interopRequireDefault(_bluebird);
	
	var _listeners = __webpack_require__(47);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _bluebird2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _bluebird2.default.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var INTERVAL_MSGS = 5000;
	
	var formatMessage = function formatMessage(msg, initialEvent) {
	  if (typeof msg === 'string') {
	    return {
	      platform: initialEvent.platform,
	      user: initialEvent.user,
	      type: 'text',
	      text: msg,
	      raw: {
	        user: initialEvent.user,
	        message: msg
	      }
	    };
	  } else if (typeof msg === 'function') {
	    // This is a 'wrapped' or 'delayed' execution message
	    // It is going to be evaluated at send time, this this has a risk of failing
	    // If the function execution fails
	    return msg;
	  } else {
	    if (msg && msg.type && msg.platform && msg.text) {
	      return msg;
	    } else {
	      throw new Error('Invalid message: ', msg);
	    }
	  }
	};
	
	var formatBloc = function formatBloc(blocName) {
	  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	  if (!_lodash2.default.isString(blocName)) {
	    throw new Error('Invalid bloc name, espected string');
	  }
	
	  return {
	    isBloc: true,
	    bloc: blocName,
	    data: data
	  };
	};
	
	var isBlocCall = function isBlocCall(args) {
	  return _lodash2.default.isString(args[0]) && args[0].startsWith('#');
	};
	
	var validateHandlers = function validateHandlers(handlers) {
	  if (_lodash2.default.isFunction(handlers)) {
	    return [{
	      default: true,
	      callback: handlers
	    }];
	  }
	
	  if (!_lodash2.default.isArray(handlers)) {
	    throw new Error('Invalid handler(s) for question, expected a function or an array of handlers (see doc).');
	  }
	
	  return handlers;
	};
	
	var Thread = function (_EventEmmiter) {
	  _inherits(Thread, _EventEmmiter);
	
	  function Thread(name, bp, convo) {
	    _classCallCheck(this, Thread);
	
	    var _this = _possibleConstructorReturn(this, (Thread.__proto__ || Object.getPrototypeOf(Thread)).call(this));
	
	    _this.initialEvent = convo.initialEvent;
	    _this.name = name;
	    _this.bp = bp;
	    _this.convo = convo;
	    _this.queue = []; // Queue of messages and questions to say / ask next
	    _this.archive = []; // Archive of unqueued questions. We store them so we can re-create (restart) the thread.
	    _this.waiting = false; // Thread is waiting when it asked for a question
	    _this._last = null;
	    return _this;
	  }
	
	  _createClass(Thread, [{
	    key: 'enqueue',
	    value: function enqueue(message) {
	      this.queue.push(message);
	      this.archive.push(message);
	    }
	  }, {
	    key: 'addMessage',
	    value: function addMessage(msg) {
	      if (isBlocCall(arguments)) {
	        // Add bloc
	        var blocName = arguments[0];
	        var blocData = arguments[1];
	
	        return this.enqueue({
	          type: 'message',
	          message: formatBloc(blocName, blocData)
	        });
	      }
	
	      // Add raw message
	      var message = formatMessage(msg, this.initialEvent);
	      this.enqueue({
	        type: 'message',
	        message: message
	      });
	    }
	
	    // Two signatures possible:
	    // msg, handlers
	    // bloc, data, handlers
	
	  }, {
	    key: 'addQuestion',
	    value: function addQuestion(msg) {
	      var handlers = validateHandlers(_lodash2.default.last(arguments));
	
	      if (isBlocCall(arguments)) {
	        // Add bloc question
	        var blocName = arguments[0];
	        var blocData = arguments.length >= 3 // Because of handlers and data is optional
	        ? arguments[1] : null;
	
	        return this.enqueue({
	          type: 'question',
	          message: formatBloc(blocName, blocData),
	          handlers: handlers
	        });
	      }
	
	      // Add raw message question
	      var message = formatMessage(msg, this.initialEvent);
	
	      this.enqueue({
	        type: 'question',
	        message: message,
	        handlers: handlers
	      });
	    }
	  }, {
	    key: 'peek',
	    value: function peek() {
	      return this.queue.length > 0 ? this.queue[0] : null;
	    }
	  }, {
	    key: 'dequeue',
	    value: function dequeue() {
	      var msg = this.queue.shift();
	
	      this._last = msg;
	      this.waiting = msg && msg.type === 'question';
	
	      if (!msg) {
	        this.emit('done');
	      }
	
	      return msg;
	    }
	  }, {
	    key: 'process',
	    value: function process(event) {
	      var handlers = this.waiting && this._last && this._last.handlers || [];
	
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;
	
	      try {
	        for (var _iterator = handlers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var handler = _step.value;
	
	          if (handler.pattern && (0, _listeners.matches)(handler.pattern, event)) {
	            if (_lodash2.default.isRegExp(handler.pattern)) {
	              var match = handler.pattern.exec(event.text);
	              if (match) {
	                event.match = match[1];
	              }
	            }
	
	            handler.callback && handler.callback(event);
	            return; // Interrupt further processing
	          }
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	
	      var defaultHandler = _lodash2.default.find(handlers, { default: true });
	
	      defaultHandler && defaultHandler.callback && defaultHandler.callback(event);
	    }
	  }, {
	    key: 'repeat',
	    value: function repeat() {
	      return this._last && this._last.message;
	    }
	  }, {
	    key: 'restart',
	    value: function restart() {
	      this.queue = this.archive.map(function (i) {
	        return i;
	      });
	      this._last = null;
	      this.waiting = false;
	    }
	  }]);
	
	  return Thread;
	}(_eventemitter2.default);
	
	var Conversation = function (_EventEmmiter2) {
	  _inherits(Conversation, _EventEmmiter2);
	
	  function Conversation(_ref) {
	    var initialEvent = _ref.initialEvent,
	        middleware = _ref.middleware,
	        logger = _ref.logger,
	        messageTypes = _ref.messageTypes,
	        _ref$clockSpeed = _ref.clockSpeed,
	        clockSpeed = _ref$clockSpeed === undefined ? 500 : _ref$clockSpeed;
	
	    _classCallCheck(this, Conversation);
	
	    var _this2 = _possibleConstructorReturn(this, (Conversation.__proto__ || Object.getPrototypeOf(Conversation)).call(this));
	
	    _this2.logger = logger;
	    _this2.middleware = middleware;
	    _this2.initialEvent = initialEvent;
	    _this2._threads = {};
	    _this2.currentThread = null;
	    _this2.defaultThread = _this2.createThread('default');
	    _this2.status = 'new';
	    _this2.get = _this2._get;
	    _this2.set = _this2._set;
	    _this2._cache = {};
	    _this2.intervalBetweenMessages = INTERVAL_MSGS;
	    _this2._timeoutHandle = null;
	    _this2._timeoutInterval = (0, _ms2.default)('5 minutes');
	    _this2._useTimeout = false;
	    _this2._clock = setInterval(_this2.tick.bind(_this2), clockSpeed);
	    _this2._clockSpeed = clockSpeed;
	    _this2._processing = false;
	    _this2._sendLock = false;
	    _this2.messageTypes = messageTypes || ['message', 'text', 'quick_reply'];
	    _this2._outgoing = [];
	    _this2.endWhenDone = true;
	
	    _this2.sendNext(); // Infinite loop. Must be called only once.
	    return _this2;
	  }
	
	  _createClass(Conversation, [{
	    key: 'sendNext',
	    value: function () {
	      var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	        var msg, data;
	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                if (!this._sendLock) {
	                  _context.next = 4;
	                  break;
	                }
	
	                return _context.abrupt('return');
	
	              case 4:
	                this._sendLock = true;
	
	              case 5:
	                _context.prev = 5;
	                msg = this._outgoing.shift();
	
	                if (!msg) {
	                  _context.next = 22;
	                  break;
	                }
	
	                if (!(msg.isBloc === true)) {
	                  _context.next = 20;
	                  break;
	                }
	
	                if (!(!this.initialEvent || !this.initialEvent.reply)) {
	                  _context.next = 11;
	                  break;
	                }
	
	                throw new Error("Convo doesn't have default event or does not support UMM");
	
	              case 11:
	                data = msg.data;
	
	                if (!_lodash2.default.isFunction(data)) {
	                  _context.next = 16;
	                  break;
	                }
	
	                _context.next = 15;
	                return _bluebird2.default.resolve(data());
	
	              case 15:
	                data = _context.sent;
	
	              case 16:
	                _context.next = 18;
	                return _bluebird2.default.resolve(this.initialEvent.reply(msg.bloc, data));
	
	              case 18:
	                _context.next = 22;
	                break;
	
	              case 20:
	                _context.next = 22;
	                return _bluebird2.default.resolve(this.middleware && this.middleware.sendOutgoing && this.middleware.sendOutgoing(msg));
	
	              case 22:
	                _context.next = 24;
	                return _bluebird2.default.delay(this._clockSpeed);
	
	              case 24:
	
	                if (this.status === 'active' || this._outgoing.length > 0) {
	                  setImmediate(this.sendNext.bind(this));
	                }
	
	              case 25:
	                _context.prev = 25;
	
	                this._sendLock = false;
	                return _context.finish(25);
	
	              case 28:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this, [[5,, 25, 28]]);
	      }));
	
	      function sendNext() {
	        return _ref2.apply(this, arguments);
	      }
	
	      return sendNext;
	    }()
	  }, {
	    key: 'teardown',
	    value: function teardown() {
	      // Dispose of timeouts and intervals
	      clearInterval(this._clock);
	      this.clearTimeout();
	      this.status = 'destroyed';
	    }
	  }, {
	    key: 'getCurrentThread',
	    value: function getCurrentThread() {
	      return this._threads[this.currentThread];
	    }
	  }, {
	    key: 'tick',
	    value: function tick() {
	      var thread = this.getCurrentThread();
	      if (this.status === 'active' && !thread.waiting && !!thread.peek()) {
	        this.next();
	      }
	    }
	  }, {
	    key: 'clearTimeout',
	    value: function clearTimeout() {
	      if (this._timeoutHandle) {
	        this.clearTimeout(this._timeoutHandle);
	      }
	    }
	  }, {
	    key: 'resetTimeout',
	    value: function resetTimeout() {
	      var _this3 = this;
	
	      this.clearTimeout();
	
	      this._timeoutHandle = this._useTimeout && setTimeout(function () {
	        // TODO If there's a timeout thread, switch to it
	        _this3.emit('timeout');
	      }, this._timeoutInterval);
	    }
	  }, {
	    key: 'createThread',
	    value: function createThread(name) {
	      var thread = new Thread(name, this.bp, this);
	      this._threads[name] = thread;
	
	      if (!this.currentThread) {
	        this.currentThread = name;
	      }
	
	      return thread;
	    }
	  }, {
	    key: 'switchTo',
	    value: function () {
	      var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(name) {
	        var restart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	        var before, thread;
	        return regeneratorRuntime.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                if (!(this.currentThread === name)) {
	                  _context2.next = 2;
	                  break;
	                }
	
	                return _context2.abrupt('return');
	
	              case 2:
	                if (this._threads[name]) {
	                  _context2.next = 4;
	                  break;
	                }
	
	                throw new Error('Thread "' + name + '" doesn\'t exist');
	
	              case 4:
	                _context2.next = 6;
	                return this.emitAsync('beforeSwitch', name);
	
	              case 6:
	                before = _context2.sent;
	
	                if (!_lodash2.default.some(before, function (a) {
	                  return a === false;
	                })) {
	                  _context2.next = 9;
	                  break;
	                }
	
	                return _context2.abrupt('return');
	
	              case 9:
	
	                this.currentThread = name;
	
	                if (restart) {
	                  thread = this.getCurrentThread();
	
	                  thread && thread.restart();
	                }
	
	                this.emit('switched', name);
	
	              case 12:
	              case 'end':
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));
	
	      function switchTo(_x2) {
	        return _ref3.apply(this, arguments);
	      }
	
	      return switchTo;
	    }()
	  }, {
	    key: 'next',
	    value: function next() {
	      var thread = this.getCurrentThread();
	      var msg = thread.dequeue();
	      if (msg) {
	        var message = msg.message;
	
	        if (typeof message === 'function') {
	          // Executes (unwrap) the message on the fly
	          message = msg.message();
	        }
	
	        this.say(message, this.initialEvent);
	      } else {
	        this.endWhenDone && this.stop('done');
	      }
	    }
	  }, {
	    key: 'processIncoming',
	    value: function () {
	      var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(event) {
	        var before, thread;
	        return regeneratorRuntime.wrap(function _callee3$(_context3) {
	          while (1) {
	            switch (_context3.prev = _context3.next) {
	              case 0:
	                if (_lodash2.default.includes(this.messageTypes, event.type)) {
	                  _context3.next = 2;
	                  break;
	                }
	
	                return _context3.abrupt('return');
	
	              case 2:
	
	                this._timeoutHandle && this.resetTimeout();
	                _context3.next = 5;
	                return this.emitAsync('beforeProcessing', event);
	
	              case 5:
	                before = _context3.sent;
	
	                if (!_lodash2.default.some(before, function (a) {
	                  return a === false;
	                })) {
	                  _context3.next = 8;
	                  break;
	                }
	
	                return _context3.abrupt('return');
	
	              case 8:
	                thread = this.getCurrentThread();
	
	                thread && thread.waiting && thread.process(event);
	
	              case 10:
	              case 'end':
	                return _context3.stop();
	            }
	          }
	        }, _callee3, this);
	      }));
	
	      function processIncoming(_x4) {
	        return _ref4.apply(this, arguments);
	      }
	
	      return processIncoming;
	    }()
	  }, {
	    key: 'setTimeout',
	    value: function setTimeout(timeout) {
	      this._useTimeout = true;
	      this._timeoutInterval = typeof timeout === 'number' ? timeout : (0, _ms2.default)(timeout);
	      this.resetTimeout();
	    }
	  }, {
	    key: 'say',
	    value: function () {
	      var _ref5 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4(msg) {
	        var message,
	            _args4 = arguments;
	        return regeneratorRuntime.wrap(function _callee4$(_context4) {
	          while (1) {
	            switch (_context4.prev = _context4.next) {
	              case 0:
	                message = null;
	
	
	                if (msg && msg.isBloc === true) {
	                  message = msg;
	                } else {
	                  message = isBlocCall(_args4) ? formatBloc.apply(undefined, _args4) : formatMessage(msg);
	                }
	
	                this._outgoing.push(message);
	
	                if (this.status !== 'active') {
	                  this.sendNext(); // restart sending process once
	                }
	
	              case 4:
	              case 'end':
	                return _context4.stop();
	            }
	          }
	        }, _callee4, this);
	      }));
	
	      function say(_x5) {
	        return _ref5.apply(this, arguments);
	      }
	
	      return say;
	    }()
	  }, {
	    key: 'activate',
	    value: function activate() {
	      if (this.status === 'new') {
	        this.status = 'active';
	        this.emit('activated');
	      } else {
	        throw new Error('Conversation was already activated');
	      }
	    }
	  }, {
	    key: 'getStatus',
	    value: function getStatus() {
	      return this.status;
	    }
	  }, {
	    key: '_get',
	    value: function _get(name) {
	      return this._cache[name];
	    }
	  }, {
	    key: '_set',
	    value: function _set(name, value) {
	      this._cache[name] = value;
	    }
	  }, {
	    key: 'repeat',
	    value: function () {
	      var _ref6 = _asyncToGenerator(regeneratorRuntime.mark(function _callee5() {
	        var thread, msg;
	        return regeneratorRuntime.wrap(function _callee5$(_context5) {
	          while (1) {
	            switch (_context5.prev = _context5.next) {
	              case 0:
	                thread = this._threads[this.currentThread];
	                msg = thread && thread.repeat();
	
	                if (!msg) {
	                  _context5.next = 4;
	                  break;
	                }
	
	                return _context5.abrupt('return', this.say(msg));
	
	              case 4:
	              case 'end':
	                return _context5.stop();
	            }
	          }
	        }, _callee5, this);
	      }));
	
	      function repeat() {
	        return _ref6.apply(this, arguments);
	      }
	
	      return repeat;
	    }()
	  }, {
	    key: 'stop',
	    value: function stop(reason) {
	      this.status = reason;
	      this.emit(reason);
	
	      if (reason !== 'stop') {
	        this.emit('stop', reason);
	      }
	      this.teardown();
	    }
	  }, {
	    key: 'threads',
	    get: function get() {
	      return Object.assign({}, this._threads);
	    }
	  }]);
	
	  return Conversation;
	}(_eventemitter2.default);
	
	module.exports = function (_ref7) {
	  var logger = _ref7.logger,
	      middleware = _ref7.middleware,
	      _ref7$clockSpeed = _ref7.clockSpeed,
	      clockSpeed = _ref7$clockSpeed === undefined ? 500 : _ref7$clockSpeed;
	
	  var convos = [];
	
	  var belongsToConvo = function belongsToConvo(convo, event) {
	    var initial = convo.initialEvent;
	
	    return convo.initialEvent.platform === event.platform && _lodash2.default.get(initial, 'user.id', '') === _lodash2.default.get(event, 'user.id', '');
	  };
	
	  middleware.register({
	    name: 'conversations',
	    type: 'incoming',
	    order: 25,
	    module: 'botpress',
	    description: 'Built-in conversation flow manager',
	    handler: function handler(event, next) {
	
	      // Clean up and free from memory ended conversations
	      convos = _lodash2.default.filter(convos, function (c) {
	        return _lodash2.default.includes(['new', 'active'], c.status);
	      });
	
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;
	
	      try {
	        for (var _iterator2 = convos[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var convo = _step2.value;
	
	          if (belongsToConvo(convo, event) && convo.status === 'active') {
	            convo.processIncoming(event);
	            return; // Stop the processing, only one convo per event. Swallow the event
	          }
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }
	
	      next && next(); // Don't swallow the event
	    }
	  });
	
	  var validateEvent = function validateEvent(event) {
	    if (!event || !event.type || !event.platform) {
	      throw new Error('You need to pass an original incoming event to start a conversation');
	    }
	  };
	
	  function start(event, callback) {
	    var convo = create(event);
	    callback && callback(convo);
	
	    convo.activate();
	    return convo;
	  }
	
	  function create(event) {
	    validateEvent(event);
	    var convo = new Conversation({
	      logger: logger,
	      middleware: middleware,
	      clockSpeed: clockSpeed,
	      initialEvent: event
	    });
	    convos.push(convo);
	    return convo;
	  }
	
	  function find(event) {
	    var _iteratorNormalCompletion3 = true;
	    var _didIteratorError3 = false;
	    var _iteratorError3 = undefined;
	
	    try {
	      for (var _iterator3 = convos[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	        var convo = _step3.value;
	
	        if (belongsToConvo(convo, event) && convo.status === 'active') {
	          return convo;
	        }
	      }
	    } catch (err) {
	      _didIteratorError3 = true;
	      _iteratorError3 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion3 && _iterator3.return) {
	          _iterator3.return();
	        }
	      } finally {
	        if (_didIteratorError3) {
	          throw _iteratorError3;
	        }
	      }
	    }
	  }
	
	  function destroy() {
	    var _iteratorNormalCompletion4 = true;
	    var _didIteratorError4 = false;
	    var _iteratorError4 = undefined;
	
	    try {
	      for (var _iterator4 = convos[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	        var convo = _step4.value;
	
	        convo.teardown();
	      }
	    } catch (err) {
	      _didIteratorError4 = true;
	      _iteratorError4 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion4 && _iterator4.return) {
	          _iterator4.return();
	        }
	      } finally {
	        if (_didIteratorError4) {
	          throw _iteratorError4;
	        }
	      }
	    }
	
	    convos = [];
	  }
	
	  return { start: start, create: create, find: find, destroy: destroy };
	};

/***/ },
/* 72 */
/***/ function(module, exports) {

	module.exports = {
		"name": "botpress",
		"description": "The world's first CMS for bots. Easily create, manage and extend chatbots.",
		"version": "1.0.14",
		"author": "Botpress",
		"bin": {
			"bp": "./bin/botpress",
			"botpress": "./bin/botpress"
		},
		"bugs": {
			"url": "https://github.com/botpress/botpress/issues"
		},
		"dependencies": {
			"axios": "^0.15.2",
			"babel-polyfill": "^6.23.0",
			"bluebird": "^3.4.6",
			"body-parser": "^1.15.2",
			"chalk": "^1.1.3",
			"commander": "^2.9.0",
			"dotenv": "^4.0.0",
			"email-templates": "^2.5.4",
			"eventemitter2": "^2.1.3",
			"express": "^4.14.0",
			"formidable": "^1.1.1",
			"handlebars": "^4.0.6",
			"howler": "^2.0.3",
			"js-yaml": "^3.8.4",
			"jsonwebtoken": "^7.1.9",
			"knex": "^0.12.6",
			"lodash": "^4.16.4",
			"moment": "^2.15.1",
			"ms": "^0.7.1",
			"mustache": "^2.3.0",
			"mware": "0.0.3",
			"node-machine-id": "^1.1.3",
			"nodemailer": "^2.7.2",
			"pg": "^6.1.2",
			"prompt": "^1.0.0",
			"react-codemirror": "^1.0.0",
			"socket.io": "^1.5.0",
			"socket.io-client": "^2.0.3",
			"socketio-jwt": "^4.5.0",
			"source-map-support": "^0.4.6",
			"sqlite3": "^3.1.8",
			"universal-analytics": "^0.4.8",
			"uuid": "^3.0.0",
			"winston": "^2.2.0"
		},
		"devDependencies": {
			"autoprefixer": "^6.5.3",
			"babel-cli": "^6.16.0",
			"babel-core": "^6.18.0",
			"babel-eslint": "^7.1.0",
			"babel-loader": "^6.2.5",
			"babel-plugin-root-import": "^5.1.0",
			"babel-plugin-transform-decorators-legacy": "^1.3.4",
			"babel-plugin-transform-object-rest-spread": "^6.16.0",
			"babel-preset-latest": "^6.16.0",
			"babel-preset-react": "^6.11.1",
			"babel-preset-stage-0": "^6.16.0",
			"babel-register": "^6.16.3",
			"bootstrap": "^3.3.7",
			"chai": "^3.5.0",
			"classnames": "^2.2.5",
			"copy-webpack-plugin": "^4.0.0",
			"css-loader": "^0.25.0",
			"eslint": "^3.9.0",
			"exports-loader": "^0.6.3",
			"expose-loader": "^0.7.1",
			"extract-text-webpack-plugin": "^1.0.1",
			"file-loader": "^0.9.0",
			"hard-source-webpack-plugin": "^0.3.7",
			"history": "^2.1.2",
			"json-loader": "^0.5.4",
			"keymirror": "^0.1.1",
			"mocha": "^3.1.2",
			"node-sass": "^3.13.1",
			"npm-watch": "^0.1.6",
			"nuclear-js": "^1.4.0",
			"nuclear-js-react-addons": "^0.4.1",
			"postcss-loader": "^1.1.1",
			"prop-types": "^15.5.8",
			"react": "^15.3.1",
			"react-addons-css-transition-group": "^15.3.1",
			"react-addons-update": "^15.4.2",
			"react-bootstrap": "^0.30.3",
			"react-bootstrap-button-loader": "^1.0.7",
			"react-dom": "^15.3.1",
			"react-emoji": "^0.4.4",
			"react-fontawesome": "^1.2.0",
			"react-ga": "^2.1.2",
			"react-markdown": "^2.4.5",
			"react-router": "^2.8.1",
			"react-sidebar": "^2.2.1",
			"react-sortable": "^1.2.0",
			"sass-loader": "^4.0.2",
			"script-loader": "^0.7.0",
			"simple-line-icons": "^2.4.1",
			"sinon": "^1.17.7",
			"style-loader": "^0.13.1",
			"tmp": "0.0.31",
			"uglifyjs-webpack-plugin": "^0.4.3",
			"webpack": "^1.13.2",
			"webpack-node-externals": "^1.5.4"
		},
		"engines": {
			"node": ">=4.6.0"
		},
		"homepage": "https://github.com/botpress/botpress#readme",
		"keywords": [
			"bots",
			"chatbots",
			"bot framework",
			"messenger",
			"facebook",
			"slack",
			"botkit",
			"microsoft bot framework",
			"bot builder",
			"bot",
			"chatbot",
			"api"
		],
		"license": "AGPL-3.0",
		"main": "lib/node.bundle.js",
		"repository": "git+https://github.com/botpress/botpress.git",
		"os": [
			"darwin",
			"linux",
			"win32"
		],
		"scripts": {
			"compile": "./build.sh",
			"test": "BABEL_ENV=tests mocha --compilers js:babel-core/register --require tests/index.js tests/** extensions/**/tests/**",
			"watch": "npm-watch",
			"lint": "eslint {src,extensions}/**/*.js*"
		},
		"watch": {
			"compile": {
				"patterns": [
					"src",
					"extensions"
				],
				"extensions": "js,jsx,scss,json,html"
			}
		}
	};

/***/ },
/* 73 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = function () {};

/***/ },
/* 74 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = function (bp) {
	  return {
	    install: function install() {},
	    uninstall: function uninstall() {}
	  };
	};

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _express = __webpack_require__(76);
	
	var _express2 = _interopRequireDefault(_express);
	
	var _http = __webpack_require__(77);
	
	var _http2 = _interopRequireDefault(_http);
	
	var _socket = __webpack_require__(78);
	
	var _socket2 = _interopRequireDefault(_socket);
	
	var _static = __webpack_require__(81);
	
	var _static2 = _interopRequireDefault(_static);
	
	var _api = __webpack_require__(82);
	
	var _api2 = _interopRequireDefault(_api);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	module.exports = function (bp) {
	  var serveApi = function () {
	    var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(app) {
	      var api;
	      return regeneratorRuntime.wrap(function _callee$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              api = (0, _api2.default)(bp);
	              return _context.abrupt('return', api.install(app));
	
	            case 2:
	            case 'end':
	              return _context.stop();
	          }
	        }
	      }, _callee, this);
	    }));
	
	    return function serveApi(_x) {
	      return _ref.apply(this, arguments);
	    };
	  }();
	
	  var serveSocket = function () {
	    var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(server) {
	      var socket;
	      return regeneratorRuntime.wrap(function _callee2$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              socket = (0, _socket2.default)(bp);
	              return _context2.abrupt('return', socket.install(server));
	
	            case 2:
	            case 'end':
	              return _context2.stop();
	          }
	        }
	      }, _callee2, this);
	    }));
	
	    return function serveSocket(_x2) {
	      return _ref2.apply(this, arguments);
	    };
	  }();
	
	  var serveStatic = function () {
	    var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(app) {
	      var staticStuff;
	      return regeneratorRuntime.wrap(function _callee3$(_context3) {
	        while (1) {
	          switch (_context3.prev = _context3.next) {
	            case 0:
	              staticStuff = (0, _static2.default)(bp);
	              return _context3.abrupt('return', staticStuff.install(app));
	
	            case 2:
	            case 'end':
	              return _context3.stop();
	          }
	        }
	      }, _callee3, this);
	    }));
	
	    return function serveStatic(_x3) {
	      return _ref3.apply(this, arguments);
	    };
	  }();
	
	  var start = function () {
	    var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {
	      var app, server, port;
	      return regeneratorRuntime.wrap(function _callee4$(_context4) {
	        while (1) {
	          switch (_context4.prev = _context4.next) {
	            case 0:
	              app = (0, _express2.default)();
	              server = _http2.default.createServer(app);
	              port = bp.botfile.port;
	              _context4.next = 5;
	              return serveApi(app);
	
	            case 5:
	              _context4.next = 7;
	              return serveSocket(server);
	
	            case 7:
	              _context4.next = 9;
	              return serveStatic(app);
	
	            case 9:
	              return _context4.abrupt('return', new Promise(function (resolve) {
	                server.listen(port, function () {
	                  return resolve();
	                });
	              }));
	
	            case 10:
	            case 'end':
	              return _context4.stop();
	          }
	        }
	      }, _callee4, this);
	    }));
	
	    return function start() {
	      return _ref4.apply(this, arguments);
	    };
	  }();
	
	  return { start: start };
	};

/***/ },
/* 76 */
/***/ function(module, exports) {

	module.exports = require("express");

/***/ },
/* 77 */
/***/ function(module, exports) {

	module.exports = require("http");

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _lodash = __webpack_require__(12);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _socket = __webpack_require__(79);
	
	var _socket2 = _interopRequireDefault(_socket);
	
	var _socketioJwt = __webpack_require__(80);
	
	var _socketioJwt2 = _interopRequireDefault(_socketioJwt);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	module.exports = function (bp) {
	  var install = function () {
	    var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(server) {
	      var io, admin, guest;
	      return regeneratorRuntime.wrap(function _callee$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              io = (0, _socket2.default)(server);
	              admin = io.of('/admin');
	              guest = io.of('/guest');
	
	              if (!bp.botfile.login.enabled) {
	                _context.next = 12;
	                break;
	              }
	
	              _context.t0 = admin;
	              _context.t1 = _socketioJwt2.default;
	              _context.next = 8;
	              return bp.security.getSecret();
	
	            case 8:
	              _context.t2 = _context.sent;
	              _context.t3 = {
	                secret: _context.t2,
	                handshake: true
	              };
	              _context.t4 = _context.t1.authorize.call(_context.t1, _context.t3);
	
	              _context.t0.use.call(_context.t0, _context.t4);
	
	            case 12:
	
	              admin.on('connection', function (socket) {
	                var visitorId = _lodash2.default.get(socket, 'handshake.query.visitorId');
	                bp.stats.track('socket', 'connected');
	
	                socket.on('event', function (event) {
	                  bp.events.emit(event.name, event.data, 'client', {
	                    visitorId: visitorId,
	                    socketId: socket.id,
	                    guest: false,
	                    admin: true
	                  });
	                });
	              });
	
	              guest.on('connection', function (socket) {
	                var visitorId = _lodash2.default.get(socket, 'handshake.query.visitorId');
	                bp.stats.track('socket', 'connected');
	
	                if (visitorId && visitorId.length > 0) {
	                  socket.join('visitor:' + visitorId);
	                }
	
	                socket.on('event', function (event) {
	                  bp.events.emit(event.name, event.data, 'client', {
	                    socketId: socket.id,
	                    visitorId: visitorId,
	                    guest: true,
	                    admin: false
	                  });
	                });
	              });
	
	              bp.events.onAny(function (event, data, from) {
	                if (from === 'client') {
	                  return; // we sent this ourselves
	                }
	
	                var c = event.startsWith('guest.') ? guest : admin;
	
	                if (data && (data.__socketId || data.__room)) {
	                  // Send only to this socketId or room
	                  return c.to(data.__socketId || data.__room).emit('event', {
	                    name: event,
	                    data: data
	                  });
	                }
	
	                // broadcast event to the front-end clients
	                c.emit('event', {
	                  name: event,
	                  data: data
	                });
	              });
	
	            case 15:
	            case 'end':
	              return _context.stop();
	          }
	        }
	      }, _callee, this);
	    }));
	
	    return function install(_x) {
	      return _ref.apply(this, arguments);
	    };
	  }();
	
	  return { install: install };
	};

/***/ },
/* 79 */
/***/ function(module, exports) {

	module.exports = require("socket.io");

/***/ },
/* 80 */
/***/ function(module, exports) {

	module.exports = require("socketio-jwt");

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _bluebird = __webpack_require__(25);
	
	var _bluebird2 = _interopRequireDefault(_bluebird);
	
	var _express = __webpack_require__(76);
	
	var _express2 = _interopRequireDefault(_express);
	
	var _path = __webpack_require__(3);
	
	var _path2 = _interopRequireDefault(_path);
	
	var _fs = __webpack_require__(13);
	
	var _fs2 = _interopRequireDefault(_fs);
	
	var _ms = __webpack_require__(68);
	
	var _ms2 = _interopRequireDefault(_ms);
	
	var _util = __webpack_require__(14);
	
	var _util2 = _interopRequireDefault(_util);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _bluebird2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _bluebird2.default.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } /* global BP_EDITION */
	
	module.exports = function (bp) {
	  var install = function () {
	    var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(app) {
	      var name, _module;
	
	      return regeneratorRuntime.wrap(function _callee$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	
	              for (name in bp._loadedModules) {
	                _module = bp._loadedModules[name];
	
	                serveModule(app, _module);
	              }
	
	              app.use('/js/env.js', function (req, res) {
	                var _bp$botfile$login = bp.botfile.login,
	                    tokenExpiry = _bp$botfile$login.tokenExpiry,
	                    enabled = _bp$botfile$login.enabled;
	
	                var optOutStats = !!bp.botfile.optOutStats;
	                var appName = bp.botfile.appName || 'Botpress';
	
	                var isFirstRun = bp.isFirstRun,
	                    version = bp.version;
	
	                res.contentType('text/javascript');
	                res.send('(function(window) {\n        window.NODE_ENV = "' + (process.env.NODE_ENV || 'development') + '";\n        window.DEV_MODE = ' + _util2.default.isDeveloping + ';\n        window.AUTH_ENABLED = ' + enabled + ';\n        window.AUTH_TOKEN_DURATION = ' + (0, _ms2.default)(tokenExpiry) + ';\n        window.OPT_OUT_STATS = ' + optOutStats + ';\n        window.SHOW_GUIDED_TOUR = ' + isFirstRun + ';\n        window.BOTPRESS_VERSION = "' + version + '";\n        window.APP_NAME = "' + appName + '";\n      })(window || {})');
	              });
	
	              serveCustomTheme(app);
	
	              app.use(_express2.default.static(_path2.default.join(bp.projectLocation, 'static')));
	
	              app.use(_express2.default.static(_path2.default.join(__dirname, '../lib/web')));
	
	              app.get('*', function (req, res, next) {
	                if (/html/i.test(req.headers.accept)) {
	                  if (req.url && /^\/lite\//i.test(req.url)) {
	                    return res.sendFile(_path2.default.join(__dirname, '../lib/web/lite.html'));
	                  }
	
	                  return res.sendFile(_path2.default.join(__dirname, '../lib/web/index.html'));
	                }
	                next();
	              });
	
	              return _context.abrupt('return', _bluebird2.default.resolve(true));
	
	            case 7:
	            case 'end':
	              return _context.stop();
	          }
	        }
	      }, _callee, this);
	    }));
	
	    return function install(_x) {
	      return _ref.apply(this, arguments);
	    };
	  }();
	
	  function serveModule(app, module) {
	    var name = module.name;
	    var shortName = module.name.replace(/botpress-/i, '');
	
	    if (module.settings.menuIcon === 'custom') {
	      (function () {
	        var iconRequestPath = '/img/modules/' + name + '.png';
	        var iconPath = _path2.default.join(module.root, 'icon.png');
	
	        app.get(iconRequestPath, function (req, res) {
	          try {
	            var content = _fs2.default.readFileSync(iconPath);
	            res.contentType('image/png');
	            res.send(content);
	          } catch (err) {
	            bp.logger.warn('Could not serve module icon [' + name + '] at: ' + iconPath);
	          }
	        });
	      })();
	    }
	
	    var liteDir = _path2.default.join(module.root, module.settings.liteDir || 'bin/lite');
	    var liteViews = _fs2.default.existsSync(liteDir) ? _fs2.default.readdirSync(liteDir).filter(function (b) {
	      return b.endsWith('.js');
	    }) : [];
	
	    app.get(['/js/modules/' + shortName, // The full module view
	    '/js/modules/' + name + '.js', // <<-- DEPRECATED: Will be removed shortly. Only use shortNames
	    '/js/modules/' + shortName + '/:subview' // Lite view
	    ], function (req, res) {
	      var settingsKey = module.settings.webBundle;
	      var bundlePath = _path2.default.join(module.root, settingsKey || 'bin/web.bundle.js');
	
	      if (req.params && req.params.subview) {
	        // Render lite view
	        bundlePath = _path2.default.join(liteDir, req.params.subview + '.bundle.js');
	      }
	
	      try {
	        var content = _fs2.default.readFileSync(bundlePath);
	        res.contentType('text/javascript');
	        res.send(content);
	      } catch (err) {
	        bp.logger.warn('Could not serve module [' + name + '] at: ' + bundlePath);
	        res.sendStatus(404);
	      }
	    });
	  }
	
	  function serveCustomTheme(app) {
	    var customTheme = '';
	
	    if (false) {
	      var themeLocation = _path2.default.join(bp.projectLocation, 'theme.css');
	      if (_fs2.default.existsSync(themeLocation)) {
	        customTheme = _fs2.default.readFileSync(themeLocation);
	      }
	    }
	
	    app.use('/style/custom-theme.css', function (req, res) {
	      res.contentType('text/css');
	      res.send(customTheme);
	    });
	  }
	
	  return { install: install };
	};

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _lodash = __webpack_require__(12);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _bodyParser = __webpack_require__(83);
	
	var _bodyParser2 = _interopRequireDefault(_bodyParser);
	
	var _express = __webpack_require__(76);
	
	var _express2 = _interopRequireDefault(_express);
	
	var _ServiceLocator = __webpack_require__(40);
	
	var _ServiceLocator2 = _interopRequireDefault(_ServiceLocator);
	
	var _anonymous = __webpack_require__(84);
	
	var _anonymous2 = _interopRequireDefault(_anonymous);
	
	var _secured = __webpack_require__(87);
	
	var _secured2 = _interopRequireDefault(_secured);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	var routersConditions = {};
	var routers = {};
	
	module.exports = function (bp) {
	  var _authenticationMiddleware = function () {
	    var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(req, res, next) {
	      var user;
	      return regeneratorRuntime.wrap(function _callee$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              res.maybeSendRequireLogin = function () {
	                if (!bp.botfile.login.enabled) {
	                  res.status(400).send({
	                    message: 'Login must be turned on for this API method'
	                  });
	
	                  return true;
	                } else {
	                  return false;
	                }
	              };
	
	              if (bp.botfile.login.enabled) {
	                _context.next = 3;
	                break;
	              }
	
	              return _context.abrupt('return', next());
	
	            case 3:
	              _context.next = 5;
	              return bp.security.authenticate(req.headers.authorization);
	
	            case 5:
	              user = _context.sent;
	
	              if (!!user) {
	                req.user = user;
	                next();
	              } else {
	                res.status(401).location('/login').end();
	              }
	
	            case 7:
	            case 'end':
	              return _context.stop();
	          }
	        }
	      }, _callee, this);
	    }));
	
	    return function _authenticationMiddleware(_x, _x2, _x3) {
	      return _ref.apply(this, arguments);
	    };
	  }();
	
	  var install = function () {
	    var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(app) {
	      return regeneratorRuntime.wrap(function _callee3$(_context3) {
	        while (1) {
	          switch (_context3.prev = _context3.next) {
	            case 0:
	              installRouter(app);
	              installProtector(app);
	              installMaybeUse(app);
	
	              app.maybeUse('bodyParser.json', _bodyParser2.default.json());
	              app.maybeUse('bodyParser.urlencoded', _bodyParser2.default.urlencoded({ extended: true }));
	
	              (0, _anonymous2.default)(bp, app);
	
	              app.use('/api/*', maybeApply('auth', _authenticationMiddleware));
	
	              (0, _secured2.default)(bp, app);
	
	            case 8:
	            case 'end':
	              return _context3.stop();
	          }
	        }
	      }, _callee3, this);
	    }));
	
	    return function install(_x7) {
	      return _ref3.apply(this, arguments);
	    };
	  }();
	
	  function installRouter(app) {
	    bp.getRouter = function (name, conditions) {
	      if (!/^botpress-/.test(name)) {
	        throw new Error('The name of a router must start with \'botpress-\'. Received: ' + name);
	      }
	
	      if (!routers[name]) {
	        var router = _express2.default.Router();
	        routers[name] = router;
	        app.use('/api/' + name + '/', router);
	      }
	
	      if (conditions) {
	        routersConditions[name] = Object.assign(routersConditions[name] || {}, conditions);
	      }
	
	      installProtector(routers[name]);
	      return routers[name];
	    };
	  }
	
	  function installProtector(app) {
	    app.secure = function (operation, ressource) {
	
	      var wrap = function wrap(method) {
	        return function (name, handler) {
	          return app[method].call(app, name, function () {
	            var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(req, res, next) {
	              var authorizeApi, authorized;
	              return regeneratorRuntime.wrap(function _callee2$(_context2) {
	                while (1) {
	                  switch (_context2.prev = _context2.next) {
	                    case 0:
	                      _context2.prev = 0;
	
	                      if (req.user) {
	                        _context2.next = 3;
	                        break;
	                      }
	
	                      return _context2.abrupt('return', handler(req, res, next));
	
	                    case 3:
	                      _context2.next = 5;
	                      return _ServiceLocator2.default.getService('authorizeApi', false);
	
	                    case 5:
	                      authorizeApi = _context2.sent;
	
	                      if (authorizeApi) {
	                        _context2.next = 8;
	                        break;
	                      }
	
	                      return _context2.abrupt('return', handler(req, res, next));
	
	                    case 8:
	                      _context2.next = 10;
	                      return authorizeApi({ userId: req.user.id, operation: operation, ressource: ressource });
	
	                    case 10:
	                      authorized = _context2.sent;
	
	                      if (!authorized) {
	                        _context2.next = 13;
	                        break;
	                      }
	
	                      return _context2.abrupt('return', handler(req, res, next));
	
	                    case 13:
	                      return _context2.abrupt('return', res.sendStatus(403));
	
	                    case 16:
	                      _context2.prev = 16;
	                      _context2.t0 = _context2['catch'](0);
	                      return _context2.abrupt('return', res.status(500).send({ message: _context2.t0.message }));
	
	                    case 19:
	                    case 'end':
	                      return _context2.stop();
	                  }
	                }
	              }, _callee2, this, [[0, 16]]);
	            }));
	
	            return function (_x4, _x5, _x6) {
	              return _ref2.apply(this, arguments);
	            };
	          }());
	        };
	      };
	
	      return {
	        get: wrap('get'),
	        post: wrap('post'),
	        put: wrap('put'),
	        delete: wrap('delete')
	      };
	    };
	  }
	
	  function installMaybeUse(app) {
	    app.maybeUse = function () {
	      if (arguments.length === 3) {
	        app.use(arguments[0], maybeApply(arguments[1], arguments[2]));
	      } else if (arguments.length === 2) {
	        app.use(maybeApply(arguments[0], arguments[1]));
	      }
	    };
	  }
	
	  return { install: install };
	};
	
	function maybeApply(name, fn) {
	  return function (req, res, next) {
	    var router = req.originalUrl.match(/\/api\/(botpress-[^\/]+).*$/i);
	    if (!router) {
	      return fn(req, res, next);
	    }
	
	    if (!routersConditions[router[1]]) {
	      return fn(req, res, next);
	    }
	
	    var condition = routersConditions[router[1]][name];
	    if (condition === false) {
	      next();
	    } else if (typeof condition === 'function' && condition(req) === false) {
	      next();
	    } else {
	      return fn(req, res, next);
	    }
	  };
	}

/***/ },
/* 83 */
/***/ function(module, exports) {

	module.exports = require("body-parser");

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _api = __webpack_require__(85);
	
	var _api2 = _interopRequireDefault(_api);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	module.exports = function (bp, app) {
	
	  app.post('/api/login', function () {
	    var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(req, res) {
	      var result;
	      return regeneratorRuntime.wrap(function _callee$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              bp.stats.track('api', 'auth', 'login');
	              _context.next = 3;
	              return bp.security.login(req.body.user, req.body.password, req.ip);
	
	            case 3:
	              result = _context.sent;
	
	              res.send(result);
	
	            case 5:
	            case 'end':
	              return _context.stop();
	          }
	        }
	      }, _callee, undefined);
	    }));
	
	    return function (_x, _x2) {
	      return _ref.apply(this, arguments);
	    };
	  }());
	
	  var apis = (0, _api2.default)(bp, app);
	  apis.anonymous.map(function (x) {
	    return x && x();
	  }); // Install all anonymous APIs
	};

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _accounts = __webpack_require__(86);
	
	var _accounts2 = _interopRequireDefault(_accounts);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = function (bp, app) {
	  return {
	    anonymous: [(0, _accounts2.default)(bp, app).installAnonymous],
	    secured: [(0, _accounts2.default)(bp, app).installSecured]
	  };
	};

/***/ },
/* 86 */
/***/ function(module, exports) {

	'use strict';
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	module.exports = function (bp, app) {
	
	  var installSecured = function installSecured() {
	
	    app.get('/api/my-account', function () {
	      var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(req, res) {
	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                res.send(req.user);
	
	              case 1:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, undefined);
	      }));
	
	      return function (_x, _x2) {
	        return _ref.apply(this, arguments);
	      };
	    }());
	  };
	
	  var installAnonymous = function installAnonymous() {};
	
	  return {
	    name: '[Lite] Accounts Management',
	    installSecured: installSecured,
	    installAnonymous: installAnonymous
	  };
	};

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _lodash = __webpack_require__(12);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _fs = __webpack_require__(13);
	
	var _fs2 = _interopRequireDefault(_fs);
	
	var _path = __webpack_require__(3);
	
	var _path2 = _interopRequireDefault(_path);
	
	var _uuid = __webpack_require__(55);
	
	var _uuid2 = _interopRequireDefault(_uuid);
	
	var _util = __webpack_require__(14);
	
	var _util2 = _interopRequireDefault(_util);
	
	var _api = __webpack_require__(85);
	
	var _api2 = _interopRequireDefault(_api);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	var logsSecret = _uuid2.default.v4();
	
	module.exports = function (bp, app) {
	
	  app.get('/api/ping', function (req, res) {
	    res.send('pong');
	  });
	
	  app.secure('read', 'modules/list').get('/api/modules', function (req, res) {
	    var modules = _lodash2.default.map(bp._loadedModules, function (module) {
	      return {
	        name: module.name,
	        homepage: module.homepage,
	        menuText: module.settings.menuText || module.name,
	        menuIcon: module.settings.menuIcon || 'view_module',
	        noInterface: !!module.settings.noInterface,
	        plugins: module.settings.plugins || []
	      };
	    });
	    res.send(modules);
	  });
	
	  app.secure('read', 'middleware/list').get('/api/middlewares', function (req, res) {
	    res.send(bp.middlewares.list());
	  });
	
	  app.secure('write', 'middleware/customizations').post('/api/middlewares/customizations', function (req, res) {
	    bp.stats.track('api', 'middlewares', 'customizations');
	    var middlewares = req.body.middlewares;
	
	    bp.middlewares.setCustomizations(middlewares);
	    bp.middlewares.load();
	    res.send(bp.middlewares.list());
	  });
	
	  app.secure('write', 'middleware/customizations').delete('/api/middlewares/customizations', function (req, res) {
	    bp.stats.track('api', 'middlewares', 'customizations');
	    bp.middlewares.resetCustomizations();
	    bp.middlewares.load();
	    res.send(bp.middlewares.list());
	  });
	
	  app.secure('read', 'notifications').get('/api/notifications', function (req, res) {
	    res.send(bp.notifications.load());
	  });
	
	  app.secure('read', 'bot/information').get('/api/bot/information', function (req, res) {
	    res.send(bp.about.getBotInformation());
	  });
	
	  app.secure('read', 'modules/list/community').get('/api/module/all', function (req, res) {
	    bp.modules.listAllCommunityModules().then(function (modules) {
	      return res.send(modules);
	    });
	  });
	
	  app.secure('read', 'modules/list/community').get('/api/module/hero', function (req, res) {
	    bp.modules.getRandomCommunityHero().then(function (hero) {
	      return res.send(hero);
	    });
	  });
	
	  app.get('/api/bot/production', function (req, res) {
	    res.send(!_util2.default.isDeveloping);
	  });
	
	  app.secure('read', 'modules/list/community').get('/api/bot/contributor', function (req, res) {
	    res.send(bp.bot.getContributor());
	  });
	
	  app.get('/api/license', function () {
	    var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(req, res) {
	      return regeneratorRuntime.wrap(function _callee$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              _context.t0 = res;
	              _context.next = 3;
	              return bp.licensing.getLicensing();
	
	            case 3:
	              _context.t1 = _context.sent;
	
	              _context.t0.send.call(_context.t0, _context.t1);
	
	            case 5:
	            case 'end':
	              return _context.stop();
	          }
	        }
	      }, _callee, undefined);
	    }));
	
	    return function (_x, _x2) {
	      return _ref.apply(this, arguments);
	    };
	  }());
	
	  app.secure('write', 'bot/information/license').post('/api/license', function (req, res) {
	    bp.stats.track('api', 'license', 'change');
	    bp.licensing.changeLicense(req.body.license).then(function () {
	      res.sendStatus(200);
	    }).catch(function (err) {
	      return res.status(500).send({
	        message: err && err.message
	      });
	    });
	  });
	
	  app.secure('write', 'modules/list/install').post('/api/module/install/:name', function (req, res) {
	    bp.stats.track('api', 'modules', 'install');
	    var name = req.params.name;
	
	    bp.modules.install(name).then(function () {
	      res.sendStatus(200);
	      bp.restart(1000);
	    }).catch(function (err) {
	      return res.status(500).send({
	        message: err && err.message
	      });
	    });
	  });
	
	  app.secure('write', 'modules/list/uninstall').delete('/api/module/uninstall/:name', function (req, res) {
	    bp.stats.track('api', 'modules', 'uninstall');
	    var name = req.params.name;
	
	    bp.modules.uninstall(name).then(function () {
	      res.sendStatus(200);
	      bp.restart(1000);
	    }).catch(function (err) {
	      return res.status(500).send({
	        message: err && err.message
	      });
	    });
	  });
	
	  app.delete('/api/guided-tour', function (req, res) {
	    _fs2.default.unlink(_path2.default.join(bp.projectLocation, '.welcome'), function () {
	      bp.isFirstRun = false;
	      res.sendStatus(200);
	    });
	  });
	
	  app.secure('read', 'bot/logs').get('/api/logs', function (req, res) {
	    var options = {
	      from: new Date() - 7 * 24 * 60 * 60 * 1000,
	      until: new Date(),
	      limit: req.query && req.query.limit || 50,
	      start: 0,
	      order: 'desc',
	      fields: ['message', 'level', 'timestamp']
	    };
	
	    bp.logger.query(options, function (err, results) {
	      if (err) {
	        return console.log(err);
	      }
	      res.send(results.file);
	    });
	  });
	
	  app.secure('read', 'bot/logs').get('/api/logs/key', function (req, res) {
	    res.send({ secret: logsSecret });
	  });
	
	  app.secure('read', 'bot/logs/archive').get('/logs/archive/:key', function (req, res) {
	    bp.stats.track('api', 'logs', 'archive');
	    if (req.params.key !== logsSecret) {
	      return res.sendStatus(403);
	    }
	
	    bp.logger.archiveToFile().then(function (archivePath) {
	      logsSecret = _uuid2.default.v4();
	      res.download(archivePath);
	    });
	  });
	
	  app.secure('read', 'bot/umm/blocs').get('/umm/blocs', function (req, res) {
	    var content = bp.umm.getDocument();
	    res.send({ content: content });
	  });
	
	  app.secure('read', 'bot/umm/templates').get('/umm/templates', function (req, res) {
	    res.send({ templates: bp.umm.getTemplates() });
	  });
	
	  app.secure('write', 'bot/umm/blocs').post('/umm/blocs', function (req, res) {
	    var _ref2 = req.body || {},
	        content = _ref2.content;
	
	    if (_lodash2.default.isNil(content)) {
	      return res.status(400).send({ message: 'You need to specify the content' });
	    }
	
	    bp.umm.saveDocument(content);
	
	    return res.sendStatus(200);
	  });
	
	  app.secure('write', 'bot/umm/simulation').post('/umm/simulate', function (req, res) {
	    try {
	      var _req$body = req.body,
	          context = _req$body.context,
	          content = _req$body.content,
	          outputPlatform = _req$body.outputPlatform,
	          incomingEvent = _req$body.incomingEvent;
	
	      var blocs = bp.umm.parse({ context: context, outputPlatform: outputPlatform, markdown: content, incomingEvent: incomingEvent });
	      res.send(blocs);
	    } catch (err) {
	      res.status(400).send({ message: err.message });
	    }
	  });
	
	  var apis = (0, _api2.default)(bp, app);
	  apis.secured.map(function (x) {
	    return x && x();
	  }); // Install all secured APIs
	};

/***/ }
/******/ ]);
//# sourceMappingURL=node.bundle.js.map